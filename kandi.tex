\documentclass[finnish]{tktltiki2}
% vim: set textwidth=100 :
% rubber: module pdftex

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

\usepackage{listings}
\renewcommand{\lstlistingname}{Listaus}
\lstset{captionpos=b,frame=single,language=Haskell}

\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

\usepackage[nottoc]{tocbibind}
\settocbibname{Lähteet}

\title{Haskell ja monadinen imperatiivisuus}
\author{Tuomas Starck}
\date{\today}
\level{Referaatti}
\abstract{Referaatti.}

\keywords{haskell}

% \classification{}

\begin{document}

\frontmatter

\maketitle
\makeabstract

\tableofcontents

\mainmatter

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\fixme}[1]{\emph{#1}}


\section{Johdanto}

% Jäsennelty asianmukaisesti (kenelle, miksi, millaisessa ympäristössä; ratkaisun lähestymistapa;
%  tutkimuskysymys, tulokset ja impakti; loppulukujen roolitus), pituus 1,5 - 2 s.
% Esim:
% 1.1 Peliteoria ja pelipuu
% 1.2 Minimax ja heuristiikka

\subsection{Haskell}

Haskell sai alkunsa vuonna 1987 Functional Programming and Computer Architecture -konferenssin
yhteydessä pidettyssä tapaamisessa, jossa päätettiin suunnitella ja kehittää uusi ohjelmointikieli.
Ennen Haskellia oli olemassa lukuisia funktionaalisia ohjelmointikieliä, mutta vaihtoehtojen
ylitarjonta sipraloi funktionaalisen ohjelmoinnin kentän ja hidasti sen edistystä. Kielen
kehittämistä varten perustettiin komitea, jonka tavoitteena oli luoda yksi yhtenäinen
funktionaalinen ohjelmointikieli. Komitean yksi ensimmäisistä saavutuksista oli nimetä uusi kieli
Haskelliksi.~\cite{hoh07}

\subsection{Laiskuus}

Haskell-komitean merkittävin yhteinen tavoite oli tehdä Haskellista laiska. Laiskuudella
tarkoitetaan sitä, että ohjelman lausekkeet evaluoidaan vasta silloin, kun niiden palauttama arvo on
tarpeen. Laiska suoritus mahdollistaa muun muassa äärettömien tietorakenteiden määrittelyn ja
käsittelyn, sillä Haskellin suoritusympäristö ei pyri evaluoimaan niitä loppuun saakka, joten
ohjelma ei jää jumiin.

Yleisesti ottaen Haskell-komitean pyrkimys oli käyttää olemassaolevia ja hyvin tunnettuja
tekniikoita suunnittelutyönsä pohjana. Laiskuudesta oli noin vuosikymmenen verran kokemusta
Haskellin synnyn aikaan, joten se ei ollut uusi keksintö.

Laiskuus ei ole täysin ongelmaton valinta. Laiskan suorituksen on pidettävä kirjaa siitä, mitkä osat
ohjelmaa ovat suorittamatta, ja se kasvattaa yleiskustannuksia. Kirjanpidosta seuraava hidastus on
kuitenkin vakioinen ja verrattain pieni. Suurempi ongelma on se, että laiskan suorituksen
tilavaativuutta on vaikea arvioida ja se saattaa kasvaa ylilineaarisesti. Haskelliin on siksi
lisätty sekä tietorakenteita, jotka eivät ole laiskoja, että keino pakottaa lausekkeen evaluaatio,
jolloin laiskuuden voi poistaa sellaisesta kohdasta ohjelmaa, jossa se on haitaksi.

\subsection{Puhtaus}

Laiskuuden välitön seuraus on se, että evaluointijärjestys määräytyy tarpeen mukaan, jolloin
vastaavasti sivuvaikutusten käsittelyä on vaikeaa toteuttaa mielekkäästi. Sivuvaikutuksilla
tarkoitetaan esimerkiksi siirrännän käsittelyä (engl. input/output) tai yleisesti ottaen mitä
tahansa ulkoista tilanmuutosta \fixme{parempiselitys!}.

Haskell-komitean ratkaisu oli tehdä Haskellista puhdas kieli, jolloin funktioilla ei ole lainkaan
sivuvaikutuksia. Tässä mielessä Haskellin funktiot ovat paitsi nimeltään niin myös merkitykseltään
vastaavanlaisia matemaattisten funktioiden kanssa -- molemmat palauttavat samalla syötteellä aina
saman arvon.

Puhtauden vaikutukset ovat kaikenkattavat. Koska sivuvaikutuksia ei sallittu, oli Haskellin
alkuaikoina siirräntä tuskallisen hankalaa. Pakon edessä kehitettiin monadinen siirräntä, jota
voidaan pitää yhtenä Haskellin merkittävimmistä panostuksista ohjelmointikielten kehitykselle.
Keskustelu siitä, onko puhtaan kielen ja monadisten sivuvaikutusten yhdistelmä paras lähestymistapa
ohjelmistojen kehitykselle, on yhä kesken, mutta Haskellin tarjoama ehdotus on ainakin mullistava ja
elegantti. Lisäksi sen on synnyttänyt paljon tutkimusta monadeista ja tilan kapseloinnista.

\subsection{Tyyppiluokat}

Tyyppiluokkia pidetään nykyisin yhtenä Haskellin tunnusmerkillisimmistä ominaisuuksista. Alunperin
tyyppiluokat tuotiin osaksi kieltä, koska oli tarve ratkaista yhtäsuuruuden vertaamisen ja
numeeristen operaatioiden ylikuormitus. Haskell-komitean tavoite oli suunnitella kieli käyttäen
olemassaolevia ja perusteellisesti tunnettuja menetelmiä, mutta Haskellia edeltäneissä
funktionaalisissa kielissä, kuten Mirandassa tai Standard ML:ssä, ei ylikuormitusta oltu ratkaistu
yhtenäisellä tavalla. Lisäksi aiemmin käytetyissä menetelmissä oli heikkouksia, kuten esimerkiksi
Mirandan polymorfinen yhtäsuuruusvertailu \fixme{laajenna?}, joka saattoi johtaa ajonaikaisiin
virhetilanteisiin.

Tyyppiluokat mahdollistavat nimensä mukaisesti tyyppien luokittelun sen perusteella, mitä
ylikuormitettuja operaatioita ne tukevat. Esimerkiksi Haskellissa luokkaan \code{Eq} kuuluvalle
tyypille on toteutettu yhtäsuuruusvertailu. Tällöin käännösvaiheessa on mahdollista tarkistaa, että
\code{==}-operaattoria käytetään vain sellaisten tyyppien kesken, jotka kuuluvat
\code{Eq}-luokkaan. Vaikka tyyppiluokat olivat uusi keksintö eikä niiden toimivuutta oltu
todistettu aiemmin, Haskell-komitea päätyi omaksumaan ne osaksi kieltä, sillä niiden avulla kaikkien
tyyppien ylikuormitus oli ratkaistavissa yhtenäisellä, järjestelmällisellä ja modulaarisella
tavalla.

\fixme{FIXME} Jälkikäteen ajateltuna tyyppiluokkien ottaminen osaksi Haskellia oli onnekas valinta,
jolla on ollut kauaskantoisia vaikutuksia, sillä tyyppiluokat ovat monikäyttöinen työkalu ja niiden
avulla voi tehdä paljon muutakin kuin toteuttaa ylikuormituksen. Yksi merkittävä edistysaskel
Haskellin ja tyyppiluokkien kehitykselle oli ehdotus tyyppimuodostajan parametroimisesta
tyyppimuuttujan sijaan. Tämä mahdollisti korkeamman asteen polymorfismin (engl. higher-kinded
polymorphism), jonka välitön sovellus oli monadien toteuttaminen.

\subsection{Monadit / monadien historiaa / jotain}

\fixme{FIXME}

\section{Siirrännän vaikeus laiskassa ja puhtaassa kielessä}

% Purkaa auki teknisemmälle yleisölle samalla käsitteitä määritellen tutkimuskysymyksen, ratkaisuille
%  ympäristöstä esiintulevat vaatimukset ja keskeiset käsitteet näiden asioiden esittelemiseksi.
% Antaa riittävästi termistöä ja kysymyksenasetteluja, jotta myöhempänä teksissä on mahdollisuus
%  analyysiin ja evaluointiin.

\fixme{Ehkä esittele pseudokoodi tässä. Ja tyyppimääritelmät.}

\subsection{Puhtaus}

Puhtaasta laskennasta on monia hyötyjä. Esimerkiksi rinnakkaista ohjelmointia pidetään perinteisesti
vaikeana ja yksi merkittävä syy ohjelmointivirheille on se, että suorituksen eri haarat lukevat tai
muuttavat jaettua tilaa virheellisesti. Puhdas rinnakkainen laskenta sen sijaan on
sivuvaikutuksetonta, joten se on immuuni samoille ongelmille.

% https://en.wikipedia.org/wiki/Dijkstra_Prize

Sivuvaikutusten puute tarkoittaa myös sitä, että Haskell on viitteellisesti läpinäkyvä (engl.
\emph{referentially transparent}). Toisin sanoen minkä tahansa Haskellin lausekkeen voi korvata
kyseisen lausekkeen arvolla ilman, että ohjelman merkitys muuttuu. Käytännössä viitteellinen
läpinäkyvyys mahdollistaa optimoinnin, jossa kääntäjä pelkistää kaikki toistuvat viitteet yhdeksi.
Esimerkiksi listauksessa~\ref{lst:kuutio} muuttujan \code{x} arvo pitää selvitää vain kerran, jonka
jälkeen saadulla \code{x}:n arvolla korvataan jokainen \code{x}:n ilmentymä ja kertolaskut voidaan
laskea.

\begin{lstlisting}[label={lst:kuutio},caption={Puhdasta laskentaa}]
kuutio x = x * x * x
\end{lstlisting}

Esimerkin yksinkertaisuus saattaa hämätä, joten on syytä muistaa, että \code{x} voi olla
laskennallisesti mielivaltaisen haastava funktio, joten optimointi voi olla merkittävä. Lisäksi
ilman puhtautta \code{x}:n arvo saattaisi olla riippuvainen esimerkiksi ulkoisesta syötteestä,
jolloin optimointia ei voisi tehdä yhtä huolettomasti. Toisaalta aina puhtaudesta johtuva
optimointi ei johda toivottuun lopputulokseen.

\begin{lstlisting}[label={lst:samat},caption={Kaksi samaa funktiota}]
lueKaksiRivia = { readLine; readLine }
\end{lstlisting}

Esimerkissä~\ref{lst:samat} käytetään kahdesti samaa funktiota, jonka tarkoitus on lukea käyttäjän
antama syöte. Koska kääntäjä luottaa puhtauteen ja optimoi identtiset funktiot yhdeksi
evaluaatioksi, tapahtuu varsinainen luku vain kerran, sillä sen jälkeen molempien funktioiden
ilmentymä voidaan korvata kerran tehdyn evaluaation palauttamalla arvolla. Siirrännän käsittelyssä
puhtaus ja sen seuraukset eivät aina ole toivottavia.

\subsection{Laiskuus}

Laiska suoritus sopii hyvin yhteen puhtaan funktionaalisen kielen kanssa, mutta sekin tekee
siirrännän käsittelyn vaikeaksi. Listauksessa~\ref{lst:tulostus} on esimerkkiohjelma, jossa
määritellään funktio \code{sanoHaskell}, joka tarkoitus on tulostaa merkkijono `Haskell'
oletustulostusvirtaan.

\begin{lstlisting}[label={lst:tulostus},caption={Tulostava esimerkkiohjelma}]
sanoHaskell = print 'Haskell'
\end{lstlisting}

Imperatiiviseen paradigmaan tottunut saattaisi olettaa, että ohjelma tulostaa `Haskell' ja lopettaa.
Laiska suoritus kuitenkin johtaa siihen, ettei mitään tulostu. Funktiota \code{print} ei koskaan
evaluoida, sillä sivuvaikutuksista ei välitetä eikä funktio palauta mitään sellaista arvoa, joka on
tarpeen ohjelman suorittamiseksi. Toisin sanoen ohjelman tulostus optimoidaan pois, vaikka se on
ohjelman ainoa varsinainen tarkoitus.

Laiskuuteen ja siirräntään liittyy myös toinen ongelma, joka on hieman hienovaraisempi.
Listauksen~\ref{lst:jarjestys} esimerkkissä määritellään funktio \code{sanoHeiMaailma}, jonka on
tarkoitus suorittaa kaksi merkkijonon tulostusta. Imperatiivisissa ohjelmissa suoritus on
tavanomaisesti ahnetta ja ohjelman suoritus seuraa kirjoitetun koodin rakennetta, mutta sama sääntö
ei päde laiskaan evaluointiin. Tästä seuraa se, ettei meillä ole mitään takeita siitä, missä
järjestyksessä esimerkkiohjelman tulostukset suoritetaan.

\begin{lstlisting}[label={lst:jarjestys},caption={Kahden tulostuksen pseudokoodi}]
sanoHeiMaailma = { print 'Hei'; print 'maailma' }
\end{lstlisting}

Toisin sanoen siinäkin tapauksessa, että tulostukset suoritettaisiin laiskuudesta huolimatta,
saattaa merkkijono `maailma' tulostua ennen merkkijonoa `Hei'. Tämä on luonnollisesti merkittävä
ongelma, sillä yleisessä käyttötapauksessa siirrännän käsittelyn tulee tapahtua määrätyssä
järjestyksessä, jotta ohjelma toimii tarkoituksenmukaisesti.

\subsection{Kohti imperatiivisuutta}

Listauksessa~\ref{lst:ratkaisu} on ohjelma, jonka käyttötarkoitus on sama kuin aiemmassa
listauksessa~\ref{lst:samat} eli ohjelman tulisi lukea syöte kahdesti, mutta toteutusta on
laajennettu siten, että puhtauden ja laiskuuden aiheuttamat ongelmat on pyritty ratkaisemaan.
Ratkaisussa on käytetty tekaistuja parametreja, joiden avulla suoritusjärjestys pakotetaan
halutunlaiseksi. Tekaistujen parametrien tyyppi ei ole tärkeä, ja listauksessa käytetty määrittely
\code{Int} on valittu vain yhtenä esimerkkinä kaikista mahdollisuuksista.

\begin{lstlisting}[label={lst:ratkaisu},caption={Suoritusjärjestys riippuvuuksien avulla}]
lueRivi       :: Int -> ( String,  Int)
lueKaksiRivia :: Int -> ([String], Int)

lueKaksiRivia p0 = ([s1, s2], p2) where
  (s1, p1) = lueRivi p0
  (s2, p2) = lueRivi p1
\end{lstlisting}

Funktio \code{lueKaksiRivia} palauttaa arvot \code{s1} ja \code{s2}, jotka edustavat niitä
merkkijonosyötteitä, joiden lukeminen on ohjelman varsinainen tavoite. Lisäksi ohjelma palauttaa
tekaistun arvon \code{p2}. Ohjelman toiminta on helpoin päätellä seuraamalla ohjelman suoritusta
kääteisessä järjestyksessä. Jotta \code{p2}:n arvo saadaan selville, on välttämätöntä suorittaa
funktio \code{lueRivi p1}. Jotta se voidaan suorittaa, täytyy saada selville arvo \code{p1}, joka
vuorostaan vaatii funktion \code{lueRivi p0} suorituksen ensin. Tällöin tekaistuilla parametreilla
on saavutettu se, että funktioilla \code{lueRivi} on muuttujien arvoon liittyvä riippuvuus, jolloin
laiska suoritus ei voi poimia suoritusjärjestystä mielivaltaisesti.

Samalla vältetään puhtaudesta juontuvat ongelmat. Funktioita \code{lueRivi p0} ja \code{lueRivi p1}
ei voi pelkistää yhdeksi evaluaatioksi, sillä saavat eri parametrit.

Funktion \code{lueKaksiRivia} saama parametri \code{p0} ei ole välttämätön tämän esimerkin kannalta,
mutta on tärkeä laajemmassa kontekstissa, sillä se mahdollistaa funktioiden koostamisen (engl.
\emph{function composition}). Jos funktiolle \code{lueRivi} ei voisi antaa mitään parametria, ei
puhtauden ja laiskuuden ongelmia olisi voitu ratkaista tekaistuilla parametreilla. Vastaavasti ilman
parametria \code{p0} olisi funktiolla \code{lueKaksiRivia} sama ongelma laajemman ohjelman
kontekstissa. Tästä syystä ei ole lainkaan sattumaa, että käytettyjen funktioiden tyyppimääritelmät
ovat hyvin samankaltaiset, sillä molempien funktioiden on tarkoitus toteuttaa siirräntää puhtaassa
ja laiskassa kielessä.

Vaikka tämän esimerkin ohjelman voi nähdä toimivan tarkoituksenmukaisella tavalla, on se samalla
muuttunut huomattavasti monimutkaisemmaksi. Ohjelma on vaikeaselkoinen, koska eri parametrien
tarkoitus ei ole ilmeinen, ja toisaalta tekaistujen parametrien käyttö ohjelman suorituksen
ohjaamiseen on semanttisesti ongelmallista. Selkeästi on todettavissa, että Haskellissa tulee olla
parempi ratkaisu siirrännän käsittelyyn.

%% % % % % % % % % % % % %%

\section{Monadinen siirräntä}

% Keskimmäiset luvut keskittyvät kukin "opettamaan" lukijalle yhden osakysymyksen tai näkökulman
% käsiteltävään asiaan. Lukujen työnjaon tulisi olla selkeä ja niillä tulee olla selkeä oma
% rakenteensa, jonka valintaperuste on lukijalle kerrottu.

\fixme{Tässä kappaleessa kerrotaan siitä, kuinka monadit passaavat maailmaa ja toteuttavat kivasti
ja elegantisti sen, mikä edellisessä kappaleessa tehtiin käsin. Ja do-notaatiosta voi kertoa.}

\section{Luku n}

% Viimeistä edellinen luku on varsinaisen kontribuution koti: vertailu, soveltaminen, osien
% synteesi ja mahdolliset evaluointimenetelmät ja -tulokset pääroolissa.

\section{Yhteenveto}

% Yleensä hieman johdantoa lyhyempi.
% Muistuttaa mieleen tutkimuskysymyksen, mainitsee tärkeimmät tulokset ja niiden perusteet.
%  Keskittyy impaktiin ja esimerkiksi suosituksiin. Ei vain summeeraa luku kerrallaan aikaisempaa
%  tekstiä.

%% % % % % % % % % % % % %%

% Monad
% http://lambda-the-ultimate.org/node/3051
% https://jeltsch.wordpress.com/2013/02/09/some-interesting-features-of-haskells-type-system
% * kinds == types of types
% * type classes: kind *
% * constructor classes: kind * -> *
% * multiparameter type classes: e.g. conversion val -> val'

\bibliographystyle{babalpha-lf}
\bibliography{viitteet}

\end{document}

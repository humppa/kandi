\documentclass[finnish]{tktltiki2}
% vim: set textwidth=100 :
% rubber: module pdftex

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

\usepackage{listings}
\renewcommand{\lstlistingname}{Listaus}
\lstset{captionpos=b,frame=single,language=Haskell,literate={ä}{{\"a}}1}

\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

\usepackage[nottoc]{tocbibind}
\settocbibname{Lähteet}

\title{Haskell ja monadinen imperatiivisuus}
\author{Tuomas Starck}
\date{\today}
\level{Referaatti}
\abstract{Referaatti.}

\keywords{haskell}

% \classification{}

\begin{document}

\frontmatter

\maketitle
\makeabstract

\tableofcontents

\mainmatter

\newcommand{\arr}[0]{\rightarrow}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\fixme}[1]{\emph{#1}}


\section{Johdanto}

% Jäsennelty asianmukaisesti (kenelle, miksi, millaisessa ympäristössä; ratkaisun lähestymistapa;
%  tutkimuskysymys, tulokset ja impakti; loppulukujen roolitus), pituus 1,5 - 2 s.
% Esim:
% 1.1 Peliteoria ja pelipuu
% 1.2 Minimax ja heuristiikka

\fixme{Johdanto: (1) Taustaa (2) Mitä teksti käsittelee}

\subsection{Haskell}

Haskell sai alkunsa vuonna 1987 Functional Programming and Computer Architecture -konferenssin
yhteydessä pidettyssä tapaamisessa, jossa päätettiin suunnitella ja kehittää uusi ohjelmointikieli.
Ennen Haskellia oli olemassa lukuisia funktionaalisia ohjelmointikieliä, mutta vaihtoehtojen
ylitarjonta sipraloi funktionaalisen ohjelmoinnin kentän ja hidasti sen edistystä. Kielen
kehittämistä varten perustettiin komitea, jonka tavoitteena oli luoda yksi yhtenäinen
funktionaalinen ohjelmointikieli. Komitean yksi ensimmäisistä saavutuksista oli uuden kielen
nimeäminen Haskelliksi.

\subsection{Laiskuus}
\label{subsec:laiskuus}

Haskell-komitean merkittävin yhteinen tavoite oli tehdä Haskellista laiska. Laiskuudella
tarkoitetaan sitä, että ohjelman lausekkeet evaluoidaan vasta silloin, kun niiden palauttama arvo on
tarpeen. Laiska suoritus mahdollistaa muun muassa äärettömien tietorakenteiden määrittelyn ja
käsittelyn, sillä Haskellin suoritusympäristö ei pyri evaluoimaan niitä loppuun saakka, joten
ohjelma ei jää jumiin.

Yleisesti ottaen Haskell-komitean pyrkimys oli käyttää olemassaolevia ja hyvin tunnettuja
tekniikoita suunnittelutyönsä pohjana. Laiskuudesta oli noin vuosikymmenen verran kokemusta
Haskellin synnyn aikaan, joten se ei ollut uusi keksintö.

Laiskuus ei ole täysin ongelmaton valinta. Laiskan suorituksen on pidettävä kirjaa siitä, mitkä osat
ohjelmaa ovat suorittamatta, ja se kasvattaa yleiskustannuksia. Kirjanpidosta seuraava hidastus on
kuitenkin vakioinen ja verrattain pieni. Suurempi ongelma on se, että laiskan suorituksen
tilavaativuutta on vaikea arvioida ja se saattaa kasvaa ylilineaarisesti. Haskelliin on siksi
lisätty sekä tietorakenteita, jotka eivät ole laiskoja, että keino pakottaa lausekkeen evaluaatio,
jolloin laiskuuden voi poistaa sellaisesta kohdasta ohjelmaa, jossa se on haitaksi.

\subsection{Puhtaus}

Laiskuuden välitön seuraus on se, että evaluointijärjestys määräytyy tarpeen mukaan, jolloin
vastaavasti sivuvaikutusten käsittelyä on vaikeaa toteuttaa mielekkäästi. Sivuvaikutuksilla
tarkoitetaan esimerkiksi siirrännän käsittelyä (engl. \emph{input/output}) tai yleisesti ottaen mitä
tahansa ulkoista tilanmuutosta~\fixme{parempiselitys!}.

Haskell-komitean ratkaisu oli tehdä Haskellista puhdas kieli, jolloin funktioilla ei ole lainkaan
sivuvaikutuksia. Tässä mielessä Haskellin funktiot ovat paitsi nimeltään niin myös merkitykseltään
vastaavanlaisia matemaattisten funktioiden kanssa -- molemmat palauttavat samalla syötteellä aina
saman arvon.

Puhtauden vaikutukset ovat kaikenkattavat. Koska sivuvaikutuksia ei sallittu, oli Haskellin
alkuaikoina siirräntä tuskallisen hankalaa. Pakon edessä kehitettiin monadinen siirräntä, jota
voidaan pitää yhtenä Haskellin merkittävimmistä panostuksista ohjelmointikielten kehitykselle.
Keskustelu siitä, onko puhtaan kielen ja monadisten sivuvaikutusten yhdistelmä paras lähestymistapa
ohjelmistojen kehitykselle, on yhä kesken, mutta Haskellin tarjoama ehdotus on ainakin mullistava ja
elegantti. Lisäksi se on synnyttänyt paljon tutkimusta monadeista ja tilan kapseloinnista.

\subsection{Tyyppiluokat}

Tyyppiluokkia pidetään nykyisin yhtenä Haskellin tunnusmerkillisimmistä ominaisuuksista. Alunperin
tyyppiluokat tuotiin osaksi kieltä, koska oli tarve ratkaista yhtäsuuruuden vertaamisen ja
numeeristen operaatioiden ylikuormitus. Haskell-komitean tavoite oli suunnitella kieli käyttäen
olemassaolevia ja perusteellisesti tunnettuja menetelmiä, mutta Haskellia edeltäneissä
funktionaalisissa kielissä, kuten Mirandassa tai Standard ML:ssä, ei ylikuormitusta oltu ratkaistu
yhtenäisellä tavalla. Lisäksi aiemmin käytetyissä menetelmissä oli heikkouksia, kuten esimerkiksi
Mirandan polymorfinen yhtäsuuruusvertailu~\fixme{laajenna?}, joka saattoi johtaa ajonaikaisiin
virhetilanteisiin.

Tyyppiluokat mahdollistavat nimensä mukaisesti tyyppien luokittelun sen perusteella, mitä
ylikuormitettuja operaatioita ne tukevat. Esimerkiksi Haskellissa luokkaan \code{Eq} kuuluvalle
tyypille on toteutettu yhtäsuuruusvertailu. Tällöin käännösvaiheessa on mahdollista tarkistaa, että
\code{==}-operaattoria käytetään vain sellaisten tyyppien kesken, jotka kuuluvat
\code{Eq}-luokkaan. Vaikka tyyppiluokat olivat uusi keksintö eikä niiden toimivuutta oltu
todistettu aiemmin, Haskell-komitea päätyi omaksumaan ne osaksi kieltä, sillä niiden avulla kaikkien
tyyppien ylikuormitus oli ratkaistavissa yhtenäisellä, järjestelmällisellä ja modulaarisella
tavalla.

Jälkikäteen ajateltuna tyyppiluokkien ottaminen osaksi Haskellia oli onnekas valinta,
jolla on ollut kauaskantoisia vaikutuksia, sillä tyyppiluokat ovat monikäyttöinen työkalu ja niiden
avulla voi tehdä paljon muutakin kuin toteuttaa ylikuormituksen. Yksi merkittävä edistysaskel
Haskellin ja tyyppiluokkien kehitykselle oli ehdotus tyyppimuodostajan parametroimisesta
tyyppimuuttujan sijaan. Tämä mahdollisti korkeamman asteen polymorfismin (engl. \emph{higher-kinded
polymorphism}), jonka välitön sovellus oli monadien toteuttaminen.

\subsection{Syntaksi}

Koodiesimerkkejä käytetään ongelmien ja ratkaisujen havainnollistamiseen. Esimerkit seuraavat
syntaksiltaan Haskellia silloinkin, kun ne ovat pseudokoodia, joka ei käänny Haskell-ohjelmaksi.
Listauksessa~\ref{lst:esittely} esitellään käytetty syntaksi, jossa on kaksi osaa: funktion tyypin
määrittely ja varsinainen funktion määrittely. Tyyppimäärittely alkaa funktion nimellä, jonka
jälkeen tulee kaksi kaksoispistettä, jota seuraa mahdolliset parametrit ja paluuarvo eroteltuna
nuolella (\code{->}). Funktion määrittely alkaa myös funktion nimellä, jota seuraa mahdolliset
parametrit (tässä esimerkissä \code{x} ja \code{y}), joiden jälkeen tulee yhtäsuuruusmerkki ja
funktion vartalo.

\begin{lstlisting}[float,label={lst:esittely},caption={Syntaksin esittely}]
summa :: Int -> Int -> Int
summa x y = x + y
\end{lstlisting}

\section{Siirrännän vaikeus laiskassa ja puhtaassa kielessä}

% Ollaanko me määritelty siirräntä missään vaiheessa? Tulostus, syötteen lukeminen, FFI,
% tilamanipulaatiot...

% Purkaa auki teknisemmälle yleisölle samalla käsitteitä määritellen tutkimuskysymyksen, ratkaisuille
%  ympäristöstä esiintulevat vaatimukset ja keskeiset käsitteet näiden asioiden esittelemiseksi.
% Antaa riittävästi termistöä ja kysymyksenasetteluja, jotta myöhempänä teksissä on mahdollisuus
%  analyysiin ja evaluointiin.

Haskellin kehityksen alkutaipaleella pohdittiin siirrännän toteuttamista ja siihen liittyviä
ongelmia. Valmista hyvänä pidettyä ratkaisua ei ollut olemassa, sillä olemassaolevien puhtaiden
funktionaalisten kielten siirräntää pidettiin epätyydyttävänä tai kielessä oli sallittu
sivuvaikutukset.

\subsection{Puhtaus}

Puhtaasta laskennasta on monia hyötyjä. \fixme{Parempi esimerkki!} Esimerkiksi rinnakkaista
ohjelmointia pidetään perinteisesti vaikeana, ja yksi merkittävä syy ohjelmointivirheille on se,
että suorituksen eri haarat lukevat tai muuttavat jaettua tilaa virheellisesti. Puhdas rinnakkainen
laskenta sen sijaan on sivuvaikutuksetonta, joten se on immuuni samoille ongelmille.

% https://en.wikipedia.org/wiki/Dijkstra_Prize

Sivuvaikutusten puute tarkoittaa myös sitä, että Haskell on viitteellisesti läpinäkyvä (engl.
\emph{referentially transparent}). Toisin sanoen minkä tahansa Haskellin lausekkeen voi korvata
kyseisen lausekkeen arvolla ilman, että ohjelman merkitys muuttuu. Käytännössä viitteellinen
läpinäkyvyys mahdollistaa optimoinnin, jossa kääntäjä pelkistää kaikki toistuvat viitteet yhdeksi.
Esimerkiksi listauksessa~\ref{lst:kuutio} muuttujan \code{x} arvo pitää selvitää vain kerran, jonka
jälkeen saadulla \code{x}:n arvolla korvataan jokainen \code{x}:n ilmentymä ja kertolaskut voidaan
laskea.

\begin{lstlisting}[float,label={lst:kuutio},caption={Puhdasta laskentaa}]
kuutio x = x * x * x
\end{lstlisting}

Esimerkin yksinkertaisuus saattaa hämätä, joten on syytä muistaa, että \code{x} voi olla
laskennallisesti mielivaltaisen haastava funktio, joten optimointi voi olla merkittävä. Lisäksi
ilman puhtautta \code{x}:n arvo saattaisi olla riippuvainen esimerkiksi ulkoisesta syötteestä,
jolloin optimointia ei voisi tehdä yhtä huolettomasti. Toisaalta aina puhtaudesta johtuva
optimointi ei johda toivottuun lopputulokseen.

\begin{lstlisting}[float,label={lst:samat},caption={Kaksi samaa funktiota}]
lueKaksiRivia = { readLine; readLine }
\end{lstlisting}

Esimerkissä~\ref{lst:samat} käytetään kahdesti samaa funktiota, jonka tarkoitus on lukea käyttäjän
antama syöte. Koska kääntäjä luottaa puhtauteen ja optimoi identtiset funktiot yhdeksi
evaluaatioksi, tapahtuu varsinainen luku vain kerran, sillä sen jälkeen molempien funktioiden
ilmentymä voidaan korvata kerran tehdyn evaluaation palauttamalla arvolla. Siirrännän käsittelyssä
puhtaus ja sen seuraukset eivät aina ole toivottavia.

\subsection{Laiskuus}

Laiska suoritus sopii hyvin yhteen puhtaan funktionaalisen kielen kanssa, mutta sekin tekee
siirrännän käsittelyn vaikeaksi. Listauksessa~\ref{lst:tulostus} on esimerkkiohjelma, jossa
määritellään funktio \code{sanoHaskell}, jonka tarkoitus on tulostaa merkkijono `Haskell'
oletustulostusvirtaan.

\begin{lstlisting}[float,label={lst:tulostus},caption={Tulostava esimerkkiohjelma}]
sanoHaskell = print "Haskell"
\end{lstlisting}

Imperatiiviseen paradigmaan tottunut saattaisi olettaa, että ohjelma tulostaa `Haskell' ja lopettaa.
Laiska suoritus kuitenkin johtaa siihen, ettei mitään tulostu. Funktiota \code{print} ei koskaan
evaluoida, sillä sivuvaikutuksista ei välitetä eikä funktio palauta mitään sellaista arvoa, joka on
tarpeen ohjelman suorittamiseksi. Toisin sanoen ohjelman tulostus optimoidaan pois, vaikka se on
ohjelman ainoa varsinainen tarkoitus.

Laiskuuteen ja siirräntään liittyy myös toinen ongelma, joka on hieman hienovaraisempi.
Listauksen~\ref{lst:jarjestys} esimerkissä määritellään funktio \code{sanoHeiMaailma}, jonka on
tarkoitus suorittaa kaksi merkkijonon tulostusta. Imperatiivisissa ohjelmissa suoritus on
tavanomaisesti ahnetta ja ohjelman suoritus seuraa kirjoitetun koodin rakennetta, mutta sama sääntö
ei päde laiskaan evaluointiin. Tästä seuraa se, ettei ole olemassa takeita siitä, missä
järjestyksessä esimerkkiohjelman tulostukset suoritetaan.

\begin{lstlisting}[float,label={lst:jarjestys},caption={Kahden tulostuksen pseudokoodi}]
sanoHeiMaailma = { print "Hei"; print " maailma" }
\end{lstlisting}

Toisin sanoen siinäkin tapauksessa, että tulostukset suoritettaisiin laiskuudesta huolimatta,
saattaa merkkijono `maailma' tulostua ennen merkkijonoa `Hei'. Tämä on luonnollisesti merkittävä
ongelma, sillä yleisessä käyttötapauksessa siirrännän käsittelyn tulee tapahtua määrätyssä
järjestyksessä, jotta ohjelma toimii tarkoituksenmukaisesti.

\subsection{Kohti imperatiivisuutta}

Listauksessa~\ref{lst:ratkaisu} on ohjelma, jonka käyttötarkoitus on sama kuin aiemmassa
listauksessa~\ref{lst:samat} eli ohjelman tulisi lukea syöte kahdesti, mutta toteutusta on
laajennettu siten, että puhtauden ja laiskuuden aiheuttamat ongelmat on pyritty ratkaisemaan.
Lisäksi tällä kertaa käytettyjen funktioiden tyyppimäärittelyt ovat kirjoitettu näkyviin.
Ratkaisussa on käytetty tekaistuja parametreja, joiden avulla suoritusjärjestys pakotetaan
halutunlaiseksi. Tekaistujen parametrien tyyppi ei ole tärkeä, ja listauksessa käytetty \code{Int}
on valittu vain yhtenä esimerkkinä kaikista mahdollisuuksista.

\begin{lstlisting}[float,label={lst:ratkaisu},caption={Suoritusjärjestys riippuvuuksien avulla}]
lueRivi       :: Int -> ( String,  Int)
lueKaksiRivia :: Int -> ([String], Int)

lueKaksiRivia p0 = ([s1, s2], p2) where
  (s1, p1) = lueRivi p0
  (s2, p2) = lueRivi p1
\end{lstlisting}

Funktio \code{lueKaksiRivia} palauttaa arvot \code{s1} ja \code{s2}, jotka edustavat niitä
merkkijonosyötteitä, joiden lukeminen on ohjelman varsinainen tavoite. Lisäksi ohjelma palauttaa
tekaistun arvon \code{p2}. Ohjelman toiminta on helpoin päätellä seuraamalla ohjelman suoritusta
kääteisessä järjestyksessä. Jotta \code{p2}:n arvo saadaan selville, on välttämätöntä suorittaa
funktio \code{lueRivi p1}. Jotta se voidaan suorittaa, täytyy saada selville arvo \code{p1}, joka
vuorostaan vaatii funktion \code{lueRivi p0} suorituksen ensin. Tällöin tekaistuilla parametreilla
on saavutettu se, että funktioilla \code{lueRivi} on muuttujien arvoon liittyvä riippuvuus, jolloin
laiska suoritus ei voi poimia suoritusjärjestystä mielivaltaisesti.

Samalla vältetään puhtaudesta juontuvat ongelmat. Funktioita \code{lueRivi p0} ja \code{lueRivi p1}
ei voi pelkistää yhdeksi evaluaatioksi, sillä ne saavat eri parametrit.

Funktion \code{lueKaksiRivia} saama parametri \code{p0} ei ole välttämätön tämän esimerkin kannalta,
mutta on tärkeä laajemmassa kontekstissa, sillä se mahdollistaa funktioiden koostamisen (engl.
\emph{function composition}). Jos funktiolle \code{lueRivi} ei voisi antaa mitään parametria, ei
puhtauden ja laiskuuden ongelmia olisi voitu ratkaista tekaistuilla parametreilla. Vastaavasti ilman
parametria \code{p0} olisi funktiolla \code{lueKaksiRivia} sama ongelma laajemman ohjelman
kontekstissa. Tästä syystä ei ole lainkaan sattumaa, että käytettyjen funktioiden tyyppimääritelmät
ovat hyvin samankaltaiset, sillä molempien funktioiden on tarkoitus toteuttaa siirräntää puhtaassa
ja laiskassa kielessä.

Vaikka tämän esimerkin ohjelman voi nähdä toimivan tarkoituksenmukaisella tavalla, on se samalla
muuttunut huomattavasti monimutkaisemmaksi. Ohjelma on vaikeaselkoinen, koska eri parametrien
tarkoitus ei ole ilmeinen, ja toisaalta tekaistujen parametrien käyttö ohjelman suorituksen
ohjaamiseen on semanttisesti ongelmallista.

% Tähän voisi lisätä monadisen I/O:n hyvät puolet:
%  composable
%  easily extensible
%  effiient
%  ^ archieved by transformations
%  extendable to interleaved I/O
%  extendable to in-place manipulation
%  only Hindley-Milner required

\section{Nimetön kappale} %% IFP: Overview

\subsection{Toiminto ja suoritus}

% We need a way to reconcile being with doing: an expression in a functional language denotes a value,
% while an I/O command should perform an action.
% action -- toimintoa // perform -- suorittaa

Ratkaisuksia siirrännän ongelmiin Haskellissa erotellaan toisistaan olemassaoleminen ja tekeminen.
\fixme{Muotoile edellinen virke paremmin.} Funktionaalisen kielen lauseke ilmaisee arvoa, kun taas
siirräntä on luonteeltaan suorite, joka pitäisi toteuttaa. Haskelliin on siksi lisätty
\code{IO}-tyyppi, joka ilmaisee toimintoa (engl. \emph{action}), jonka suoritus (engl.
\emph{perform}) voi tehdä siirräntää ja palauttaa arvon. Jatkossa toiminnolla tarkoitetaan aina
funktiota, joka on \code{IO}-tyyppiä.

\code{IO} on yhdistelmätyyppi (engl. \emph{algebraic data type}), joka ottaa parametrikseen
palautteen tyypin. Esimerkiksi funktio tyyppiä \code{IO Int} palauttaa kokonaislukuarvon
suoritettuaan siirrännän. \code{IO}-tyypin määrittelyyn riittää klassinen
Hindley--Milner-tyyppijärjestelmä, joten sen käyttöönotto ei vaatinut muita muutoksia Haskelliin.
\fixme{HM:ää ei ole mainittu aiemmin. Se pitäisi ehkä laittaa edelliseen kappaleeseen.}

Erottelemalla toiminnon suorittamisesta \code{IO}-tyyppiset funktiot kapseloivat siirrännän siten,
että ne ovat yhteensopivat Haskellin puhtaan funktionaalisen paradigman kanssa säilyttäen
viitteellisen läpinäkyvyyden. Toisin sanoen toiminnot ovat tavallisia funktiota, joita voidaan
välittää argumenttina, koostaa osaksi korkeamman asteen funktioita (engl. \emph{function
composition}) ja yleisesti ottaen käsitella kaikilla funktionaalisen kielen keinoilla.

Toiminnon ja suorituksen erottelu johtaa luonnollisesti kysymykseen siitä, mikä saa aikaan
toimintojen suorittamisen? Haskellin ratkaisu on määritellä ohjelma toiminnoksi nimeltään
\code{main}, joka on tyyppiä \code{IO ()}, ja jonka suoritus vastaa koko ohjelman suorittamista.
Koska Haskell-ohjelma on funktionaalisesta semantiikasta johtuen mielivaltainen yhdistelmä
matalamman tason funktioita ja toimintoja, johtaa \code{main}-toiminnon suoritus myös matalan tason
toimintojen suorittamiseen silloin, kun \code{main}-toiminnon suoritus sitä vaatii.

\subsection{Toimintojen yhdistäminen}

Listauksessa~\ref{lst:bind} on ohjelma, joka lukee merkin vakiosyötteestä ja tulostaa sen
vakiotulosteeseen. Jos listauksen tyyppimääritelmät jättää huomioimatta, on tämänkertainen esimerkki
validia Haskellia, jonka voi kääntää toimivaksi ohjelmaksi. Ohjelma käyttää toimintoja \code{getChar} ja
\code{putChar}, joista ensimmäinen on tyypiltään \code{IO Char}, sillä sen suorituksen
jälkeinen paluuarvo on merkki, ja jäljempi on tyypiltään \code{Char -> IO ()}, sillä se ottaa
argumentikseen tulostettavan merkin eikä ei palauta mitään arvoa. Haskellissa tyhjiä sulkeita
käytetään olemattoman arvon merkitsemiseen, ja niiden käyttö on välttämätöntä tässä tapauksessa,
sillä \code{IO} vaatii tyyppiparametrin.

\begin{lstlisting}[float,label={lst:bind},caption={Kompositio ja sidosfunktion käyttö}]
getChar :: IO Char
putChar :: Char -> IO ()
(>>=)   :: IO a -> (a -> IO b) -> IO b

main :: IO ()
main = getChar >>= putChar
\end{lstlisting}

% bind ei ole language construct vaan ihan vaan funktio

Esimerkin toiminnot ovat yhdistetty \verb|(>>=)| funktiolla, joka luetaan \emph{bind} eli suomeksi
sidos. Bindia käytetään tavallisesti sisämerkintänä (engl. \emph{infix notation}) eli tässä esimerkissä
bind saa argumenteikseen toiminnot \code{getChar} ja \code{putChar}. Bindin toteutus ei ole
esimerkissä näkyvillä, mutta tyyppimääritelmä paljastaa oleellisen osan bindin toiminnasta.

Bind on polymorfinen funktio, jota merkitään tyyppiparametrin pienillä kirjaimilla \code{a} ja
\code{b}, jotka voi korvata millä tahansa oikealla tyypillä. Tämän esimerkin tapauksessa
Haskell-kääntäjä päättelee, että \code{a} on \code{Char} ja \code{b} on \code{()}, sillä ne
vastaavat käytettyjen toimintojen tyyppejä. Lisäksi bindin paluuarvo tyyppipäättelyn jälkeen on
\code{IO ()}, joka vastaa \code{main}-toiminnon paluuarvoa, joten ohjelma läpäisee
tyyppitarkastuksen.

Esimerkkiohjelman voi lukea seuraavalla tavalla: \code{getChar} palauttaa toiminnon \code{IO Char},
jonka \code{Char}-tyyppinen arvo tarvitaan parametriksi, jotta voidaan toteuttaa \code{putChar}:n
palauttama toiminto, joka vastaavasti tuottaa lopullisen tarvittavan arvon \code{IO ()}. Toisin
sanoen bind luo tietoriippuvuuden (engl. \emph{data dependency}) käytettyjen toimintojen välille,
jolloin laiska evaluaatio ei voi enää suorittaa siirräntätoimintoja mielivaltaisessa järjestyksessä.

\subsection{Monadi}

Bind eli \verb|(>>=)| ei ole sattumalta osa Haskellin standardikirjastoa vaan yhdessä
\code{return}-funktion kanssa ne täyttävät teoreettiset vaatimukset Haskellin Monad-tyyppiluokan
määritelmälle. Lisäksi määritelmään kuuluu myös \emph{then}, joka kirjoitetaan \verb|(>>)|.

Listauksessa~\ref{lst:monad} on lainaus Glasgow Haskell Compilerin (jatkossa \emph{GHC})
lähdekoodista, jossa Monad määritellään. \fixme{Tarvitaanko tätä ollenkaan?}

\begin{lstlisting}[float,float,label={lst:monad},caption={Monad-tyyppiluokka}]
class Applicative m => Monad m where
  (>>=)  :: forall a b. m a -> (a -> m b) -> m b
  (>>)   :: forall a b. m a -> m b -> m b
  return :: a -> m a
\end{lstlisting}

Monissa imperatiivisissa kielissa \code{return} on kielen avainsana, jonka tarkoitus on keskeyttää
aliohjelman suoritus. Haskellissa \code{return} on funktio, joka nostaa parametrinsa monadiseen
kontekstiin. \fixme{Selitäppä tuo seuraavaksi! Ehkä jokin esimerkki.}

Then, jonka voi kääntää suomeksi \emph{sitten}, on bindin erikoistapaus, jolla yhdistetään kaksi
toimintoa, joista ensimmäinen ei palauta arvoa, jota toinen toiminto käyttäisi. Then ei ole
pakollinen monadin toteuttamiseksi, mutta se on hyödyllinen käytännön ohjelmoinnin näkökulmasta.

Listauksessa~\ref{lst:then} on korjattu versio luvun~\ref{subsec:laiskuus} esimerkistä. Ohjelmaa on
muutettu niin, että tulostustoiminnot ovat yhdistetty then-funktiolla, joka takaa sen, että
tulostukset tapahtuvat aiotussa järjestyksessä. Lisäksi tyyppimääritelmä on kirjoitettu näkyviin sen
korostamiseksi, että kyseinen toiminto tulee suorittaa IO-monadin kontekstissa.

\begin{lstlisting}[float,label={lst:then},caption={Fixme}]
sanoHeiMaailma :: IO ()
sanoHeiMaailma = putStr "Hei" >> putStr " maailma"
\end{lstlisting}

\subsection{Imperatiivinen tyyli}
% Viitteeksi ehkä jotain Wadleria (kuten Comprehending Monads)

Imperatiivinen ohjelmointi soveltuu hyvin siirräntään, sillä imperatiivisen koodin rakenne ja
ohjelman semantiikka vastaavat toisiaan. Haskelliin on siksi lisätty \emph{do}-merkintätapa (engl.
\emph{do-notation}), joka mahdollistaa Haskell-ohjelmakoodin kirjoittamisen imperatiiviseen tyyliin
funktionaalisen tyylin sijaan. Do-merkintätapa on syntaktista sokeria, joten se lisää eikä vähennä
Haskellin kielellistä ilmaisuvoimaa.

Do-merkintätapa lisää Haskelliin avainsanat \code{do} ja \verb|<-|. Avainsana \code{do} aloittaa
koodilohkon, joka rajataan ympäröivästä ohjelmasta sisentämällä, ja jonka kontekstissa kääntäjä
muuntaa (engl. \emph{desugar}) rivinvaihdot monadisiksi yhdistefunktioiksi. Avainsana \verb|<-|
luetaan bind, sillä sen avulla voidaan sitoa toiminnon paluuarvo nimeen, jota käytetään myöhemmin.
Toisin sanoen kääntäjä muuntaa sen \verb|(>>=)|-funktioksi.

\begin{lstlisting}[float,label={lst:desugared},caption={Funktionaalinen tyyli}]
main :: IO ()
main = putStrLn "Mikä on nimesi?"
       >>
       getLine
       >>=
       \nimi -> putStrLn ("Hei " ++ nimi ++ "!")
\end{lstlisting}

\begin{lstlisting}[float,label={lst:donotation},caption={Imperatiivinen tyyli ja do-merkintätapa}]
main :: IO ()
main = do
  putStrLn "Mikä on nimesi?"
  nimi <- getLine
  putStrLn ("Hei " ++ nimi ++ "!")
\end{lstlisting}

Listauksessa~\ref{lst:desugared} on esimerkkiohjelma, joka kysyy käyttäjän nimeä, lukee syötteen ja
tulostaa tervehdyksen. Koska ensimmäisenä tehtävä tulostus ei palauta merkityksellistä arvoa,
käytetään seuraavaksi funktiota then. Sen sijaan \code{getLine} on tyyppiä \code{IO String}, joten
sen jälkeen käytetään funktiota bind, jotta palautettu merkkijono voidaan välittää eteenpäin.
Viimeisellä rivillä merkkijono sidotaan nimeen \code{nimi} lambda-abstraktion avulla, jotta
viimeisessä tulostuksessa siihen voidaan viitata.

Listauksessa~\ref{lst:donotation} on sama ohjelma, joka on kirjoitettu do-merkintätapaa käyttäen.
Tällöin monadisia sidosfunktioita ei tarvitse kirjoittaa eksplisiittisesti näkyviin vaan kääntäjä
päättelee niiden tarpeen ja lisää ne ennen varsinaista kääntämistä. Toiminnon \code{getLine}
palauttama arvo sidotaan avainsanalla \verb|<-| nimeen samankaltaisella syntaksilla, millä missä
tahansa imperatiivisessa kielessä aliohjelman paluuarvo tallennettaisiin muuttujaan. Kuitenkaan
\code{nimi} ei ole muuttuja, sillä sen arvoa ei voi myöhemmin muuttaa.

Monadinen siirräntä ja do-merkintätapa mahdollistaa siirräntätoimintojen kirjoittamisen
Haskell-ohjelmissa tavalla, joka on intuitiivinen ja tuttu useille ohjelmoijille, mutta samalla
Haskellin ja funktionaalisen ohjelmoinnin toivotuista ominaisuuksista pidetään kiinni:
Tyyppipäättely ja -turvallisuus auttavat ohjelmointivirheiden havaitsemista. Funktionaalisuuteen
kuuluva funktioiden ja toimintojen yhdistäminen toimii. Laiskuus ja puhtaus säilyvät.

\section{Kategoriateoria ja monadit}

\subsection{Historia}

Alunperin kategoriateoria ja monadit tulivat osaksi tietojenkäsittelytiedettä vuonna 1989 Eugenio
Moggin julkaisun "Computational Lambda-calculus and Monads"~\cite{clcam89,nocam91} myötä. Moggi
tutki ohjelmointikieliä ja keinoja, joilla tietokoneohjelmista voidaan vetää loogisia
johtopäätöksiä, kuten esimerkiksi osoittaa kahden ohjelman yhdenmukaisuus.

Lambdakalkyyli oli aiemmin tarjonnut matemaattisen teoreettisen pohjan ohjelmien yhdenmukaisuuden
vertailuun. Lambdakalkyylin ei kuitenkaan ollut ongelmaton valinta, sillä se vaati ohjelman tai
proseduurin merkityksen pelkistämisen täydelliseksi funktioksi (engl. \emph{total function}).
Tällöin menetetään mahdollisuus tarkastella muun muassa pysähtyvyyttä, epädeterministisyyttä ja
sivuvaikutuksia, jotka ovat yleisiä oikeissa ohjelmissa.

% (1) https://en.wikipedia.org/wiki/Denotational_semantics
%
% (2) "Moggi seeks to capture the intuitive notion of a computation in the most general setting
% possible." -- Kategoriateoreettinen lähestymistapa tarjoaa yhdenmukaisuudelle ja pysähtymiselle
% luonnollisen selityksen. -- "That existence and equivalence are so readily definable suggests that
% far from just being a way to hide I/O or statefulness, Monads and their attendant laws express the
% conditions satisfied by a computation strategy."

Moggin valinta oli käyttää kategoriateorian tarjoamaa semanttista kehystä laskennan mallintamiseen.
Erityisesti Moggin innovaatio oli hyödyntää monadeja, joka mahdollisti ohjelmointikielen
ominaisuuksien jakamisen erillisiin osiin niiden semantiikan perusteella. Tällöin esimerkiksi
siirräntä, poikkeukset tai muut toisistaan poikkeavat ominaisuudet saivat oman erillisen kontekstin,
jossa niitä voitiin tarkastella.

Philip Wadler havaitsi, että Moggin käyttämä strategia rakenteen luomiseen semantiikan avulla
soveltuisi myös funktionaalisten ohjelmien jäsentämiseen. Toisin sanoen siinä missä Moggi käytti
monadeja ohjelmien kuvaamiseen, päätti Wadler hyödyntää monadeja ohjelmien
ilmaisemiseen~\cite{cm90,teofp92}.

\subsection{Kategoria}

Kategoriateoria on abstrakti matemaattinen työkalu, joka on mahdollistanut monien matemaattisten
käsitteiden formalisoinnin. Kategoriateoreettinen lähdestymistapa mahdollistaa erillaisten
matemaattisten rakenteiden (kuten esimerkiksi joukkojen, ryhmien tai vektoriavaruuksien) tarkastelun
rakenteen säilyttävällä tavalla, jolloin kategorian tutkiminen sallii yhteisten piirteiden
kuvaamisen ja todistamisen.

Kategoria muodostuu kolmesta tekijästä: olioista, morfismeista ja yhdisteen käsitteestä. Morfismeja
(engl. \emph{morphisms}) kutsutaan myös nuoliksi (engl. \emph{arrow}), mutta nuolella on Haskellissa
eri merkitys, joten jatkossa pitäydytään nimityksessä morfismi. Merkintä $f : A \rightarrow B$
tarkoittaa morfismia $f$ lähdeoliolta $A$ kohdeoliolle $B$ jossain kategoriassa $\mathcal{C}$.

Yhdiste (engl. \emph{composition}) on binäärioperaatio morfismeille siten, että jos on olemassa
morfismit $f : A \arr B$ ja $g : B \arr C$, on oltava myös niiden yhdistemorfismi $g \circ f : A
\arr C$. Lisäksi morfismit noudattavat kahta sääntöä. Ensinnäkin morfismien yhdisteen tulee olla
assosiatiivinen. Toisin sanoen:

$$f \circ (g \circ h) = (f \circ g) \circ h$$

Toiseksi missä tahansa kategoriassa $\mathcal{C}$ on olemassa jokaiselle oliolle $A$
identiteettimorfismi $1_A : A \arr A$. Tarkemmin sanottuna jokaiselle morfismille $f : A \arr B$
pätee:

$$ 1_A \circ f = f = f \circ 1_B $$

Miten sitten kategoriat liittyvät Haskelliin? Haskellissa on kategoria nimeltään \code{Hask}, jonka
kontekstissa Haskellin tyypit vastaavat kategorian olioita, funktiot vastaavat morfismeja ja funktio
\verb|(.)| toimii yhdistemorfismina. Haskellissa on myös funktio \code{id}, joka täyttää
identiteettimorfismin tehtävän. Koska yhdistemorfismi \verb|(.)| on assosiatiivinen, voidaan todeta,
että kategoria \code{Hask} täyttää kategoriateorian vaatimukset.


%% Kategoriateoria (objects, morphisms, composition).
%  Funktorit (kokoelmia).
%  Monadit (luovat kontekstin).

% The category must satisfy an identity axiom and an associative axiom which is analogous
% to the monoid axioms.

%% Monadit <- kategoriateoria
%% Koska Moggi tahtoi *kuvata* ohjelmia
%% Ja sitten Wadler huomasi, että hemmetti, niillä voi myös *ilmaista* ohjelmia
%  Haskellissa monadit luodaan tyyppiluokkien avulla
%  Ja lisäksi toki return ja >>= (eli unit ja bind kategoriateorissa)
%  Haskellissa oli kätevästi tyyppiluokat valmiina, ja niiden avulla Monad:n luonti onnistui helposti.

\section{Siirrännän toteutus} %% IFP: Implementing monadic I/O

\fixme{Miten jos aluksi kertoisi monadeista kaiken, ja sitten kun monadit on kerrottu, voi kertoa,
kuinka IO-monadin kontekstissa voidaan tehdä RealWorldin passaamminen ja hävittäminen, jolloin on
kauniisti palattu takaisin listaukseen 6. Ja se että IO Monad on yksisuuntainen.}

%% % % % % % % % % % % % %%
%
% Esitellään monadit ///
% Voisi yrittää aloittaa siitä, että sanoo jotain kategoriateoriasta ///
%  Tai siitä, miksi on olemassa kategoriateoria ja monadit ///
% Monadit luovat semantiikkaa eli kontekstia eli ympäristöä ///
%  Pitää ehkä kertoa, mitä konteksti tai ympäristö tarkoittaa tässä ///
% Monadilait
%
% Monadit ovat semanttinen asia. Haskell ottaa kategoriateorian monadit ja luovat Monadin. Toisin
% sanoen Haskell mahdollistaa ohjelmoijan määritellä oman laskennallisen ympäristönsä. Eli:
% "[Moggi(1989)] offers the interpretation of a programming language into one monad, but Haskell
% reifies monads with Monad. Reification is taking a concept used to describe the semantics of a
% language and inserting it into the language itself. Monad lets Haskell programmers define their
% own computational universes."

% I/O-operaatioiden kompositio
%  Siihen tarvitaan monadeja
%  Viitteellinen läpinäkyvyys säilyy
%  doneIO & seqIO :: monoid  ||  bindIO & unitIO :: monad

% 4.3 No way out [https://wiki.haskell.org/All_About_Monads]
% The wonderful feature of a one-way monad is that it can support side-effects in its monadic
% operations but prevent them from destroying the functional properties of the non-monadic portions
% of the program.

% FFI ja C-proseduurien kutsuminen
%  Lopulta (matalalla tasolla) siirräntä toteutetaan kutsumalla C-proseduureja (käyttöjärjestelmä ja
%  standardikirjastot)
%  Haskellissa 'ccall'
%  Koko IO-järjestelmä on toteutettu Haskellilla ccall:n päälle

% Hopkins 2012 (ei julkaisutietoja) ja Moggi 1989:
%
% Jos oletetaan ohjelma P, kategoria C, käytetyn kielen (perustyyppien) tyyppimääritelmät
% kategorian C olioille ja perusoperaatiot kyseisille tyypeille (sopiville morfismeille), on
% olemassa morfismi, joka vastaa P:tä.
% Kategorian sisäinen rakenne eli se, mitä morfismeja minkä olioiden välillä on olemassa, vastaa
% sitä kokoelmaa ohjelmia, jotka ovat kielessä (mitä ohjelmia on ja millaisten tyyppien välillä).
%
% C == category
% A == object in C
% T =~ functor from C -> C
% η == natural transformation from Id on C
% Kleisi triple (T, η, *) as the world where computation can take place
%
% Haskell:
% return     == η  (injects values into computations)
% bind (>>=) == *

% Keskimmäiset luvut keskittyvät kukin "opettamaan" lukijalle yhden osakysymyksen tai näkökulman
% käsiteltävään asiaan. Lukujen työnjaon tulisi olla selkeä ja niillä tulee olla selkeä oma
% rakenteensa, jonka valintaperuste on lukijalle kerrottu.

% Functor, Applicative, Monad:
% https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#Functor #Applicative #Monad
%
% newtype IO a = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
% newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
% RealWorld token enforces ordering through data dependence.

% Haskellissa IO monadi ///
%  Haskellin 'main' on tyypiltaan 'IO ()' ///
% RealWorld on virtuaalinen asia, jota käytetään data-riippuvuuden luontiin ///
% Kuinka "IO inside" ja IFP-paperi eroaa toisistaan? ///
% Kuinka RealWorld luodaan ja kadotetaan? ///
% Kuinka puhtaus säilytetään? ///
%  Erotellaan being ja doing (oleminen ja tekeminen?) ///
%  "In our system, the value of the entire program is a single (perhaps large) action, called mainIO,
%  and the program is executed by performing this action." ///
% Syntaksi eli 'do' ja '<-'

% \section{Luku n} Viimeistä edellinen luku on varsinaisen kontribuution koti: vertailu,
% soveltaminen, osien synteesi ja mahdolliset evaluointimenetelmät ja -tulokset pääroolissa.

\section{Yhteenveto}

% Yleensä hieman johdantoa lyhyempi.
% Muistuttaa mieleen tutkimuskysymyksen, mainitsee tärkeimmät tulokset ja niiden perusteet.
%  Keskittyy impaktiin ja esimerkiksi suosituksiin. Ei vain summeeraa luku kerrallaan aikaisempaa
%  tekstiä.

% Monad
% http://lambda-the-ultimate.org/node/3051
% https://jeltsch.wordpress.com/2013/02/09/some-interesting-features-of-haskells-type-system
% * kinds == types of types
% * type classes: kind *
% * constructor classes: kind * -> *
% * multiparameter type classes: e.g. conversion val -> val'

\bibliographystyle{babalpha-lf}
\bibliography{viitteet}

\end{document}

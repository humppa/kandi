\documentclass[finnish]{tktltiki2}
% vim: set textwidth=100 :
% rubber: module pdftex

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

\usepackage{listings}
\renewcommand{\lstlistingname}{Listaus}
\lstset{basicstyle=\ttfamily,captionpos=b,frame=single,language=Haskell,literate={ä}{{\"a}}1}

\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

\usepackage[nottoc]{tocbibind}
\settocbibname{Lähteet}

\title{Haskell ja monadinen imperatiivisuus}
\author{Tuomas Starck}
\date{\today}
\level{Kandidaatintutkielma}

\abstract{ \\
Haskell on puhdas, laiska ja funktionaalinen ohjelmointikieli, joka tarjoaa vaihtoehtoisen
ohjelmointiparadigman valtavirran imperatiivisille ja oliopohjaisille kielille. Siirräntä
tarkoittaa tietokoneohjelman vuorovaikutusta ympäristönsä kanssa.

Tutkielma esittelee puhtauteen ja siirräntään liittyviä ongelmia ja tarkastelee kuinka Haskell
mahdollistaa siirrännän ohjelmoinnin hyödyntäen kategoriateorista lainattua monadien konseptia.
Teoreettisen viitekehyksen lisäksi tutkielma selittää kuinka Haskellin IO-monadi toimii ja kuinka
sen avulla on helppoa toteuttaa siirräntää.
}

\classification{ \\
Software and its engineering $\rightarrow$ Software notations and tools $\rightarrow$ General
programming languages $\rightarrow$ Language types $\rightarrow$ Functional languages
}

\keywords{Haskell, siirräntä, funktionaalinen ohjelmointi, monadit}

\begin{document}

\frontmatter

\maketitle
\makeabstract

\tableofcontents

\mainmatter

\newcommand{\arr}[0]{\rightarrow}
\newcommand{\code}[1]{\texttt{#1}}


\section{Johdanto}

Hyvälle tietokoneohjelmalle on monia vaatimuksia, kuten esimerkiksi ohjelman oikeellisuus,
soveltuvuus käyttötapaukseensa, tehokkuus ja ohjelmoijan mahdollisuudet ymmärtää ja laajentaa
ohjelmaa. Vastaavasti hyvän ohjelmointikielen tulisi tukea ohjelmoijan päämäärää hyvän ohjelman
luomisessa. Tietojenkäsittelyn historian aikana on kehitetty useita ohjelmointikieliä, joista
nykyisin yleisimmin käytössä olevat hyödyntävät imperatiivista ohjelmointiparadigmaa. Tämä tutkielma
tarkastelee ohjelmointikieltä \emph{Haskell}, joka ei ole imperatiivinen kieli, vaan kuuluu
funktionaalisten kielien joukkoon.

Imperatiivisen paradigman ohjelma mallintuu pelkistetyssä tarkastelussa suoraan matalan tason
konekäskyiksi, joten siinä mielessä se on johdonmukainen tapa lähestyä ohjelmointia. Laskenta
mikroprosessorin avulla tapahtuu siten, että prosessorin ja muistin tila muuttuvat konekäskyjä
suoritettaessa, ja vastaavasti imperatiivisen ohjelman käskyjen suoritus muuttaa ohjelman tilaa. Sen
sijaan funktionaalisen paradigman kielissä laskenta tarkoittaa ohjelman lausekkeiden sieventämistä.
Funktionaalisten kielten vahvuuksiin kuuluu vahva modulaarisuus, sillä ohjelma koostuu funktioista,
joita on mahdollista yhdistellä mielivaltaisesti~\cite{why90}.

Siirräntä (engl. \emph{input/output}) tarkoittaa tietokoneohjelman vuorovaikutusta ympäristönsä
kanssa. Haskell on paitsi funktionaalinen myös puhdas ja laiska kieli~\cite{rep92}. Puhtauden
määritelmään kuuluu, että ohjelma ei saa vuorovaikuttaa ympäristönsä kanssa eli ohjelmalla ei tule
olla sivuvaikutuksia. Koska sivuvaikutukset määritelmällisesti karkaavat ohjelman semantiikan
ulkopuolelle saattavat ne sekä tehdä ohjelman ymmärtämisen vaikeaksi että vaikeuttaa ohjelman
oikeellisuuden päättelyä.

Toisaalta tietokoneohjelma on hyödyllinen vain mikäli se voi ottaa vastaan syötettä ja ilmaista
laskennan tuloksen jollain tavalla. Toisin sanoen siirräntä on välttämätön ominaisuus hyvälle
ohjelmalle eikä mikään vakavasti otettava ohjelmointikieli voi olla huomioimatta tätä tarvetta. Myös
Haskellin oli ratkaistava tämä ilmeinen ristiriita.

Tämä tutkielma perehtyy Haskellin valintaan lainata kategoriateorian monadia teoreettiseksi malliksi
sille, kuinka siirräntä on eristetty kielen semantiikan puitteissa omaan kontekstiinsa ja
funktionaalisuuden toivotut ominaisuudet on säilytetty käyttökelpoisina~\cite{ifp93}. Tutkielma
tarkastelee myös kuinka siirrännän totettaminen on mahdollistettu ja tehty helpoksi Haskellin kielen
ominaisuuksien avulla. Mutta aluksi tutkielma luo lyhyen katsauksen Haskellin syntyyn, jotta
tekniset haasteet saavat historiallisen kontekstin.


\section{Haskell}

\subsection{Historia}

Haskell sai alkunsa vuonna 1987 Functional Programming and Computer Architecture -konferenssin
yhteydessä pidetyssä tapaamisessa, jossa päätettiin suunnitella ja kehittää uusi ohjelmointikieli.
Ennen Haskellia oli olemassa lukuisia funktionaalisia ohjelmointikieliä, mutta vaihtoehtojen
ylitarjonta sirpaloi funktionaalisen ohjelmoinnin kentän ja hidasti sen edistystä~\cite{hoh07}.
Kielen kehittämistä varten perustettiin komitea, jonka tavoitteena oli luoda yksi yhtenäinen
funktionaalinen ohjelmointikieli. Komitean yksi ensimmäisistä saavutuksista oli uuden kielen
nimeäminen Haskelliksi.

\subsection{Laiskuus}
\label{subsec:laiskuus}

Haskell-komitean merkittävin yhteinen tavoite oli tehdä Haskellista laiska (engl.
\emph{lazy})~\cite{hoh07}. Laiskuudella tarkoitetaan sitä, että ohjelman lauseke evaluoidaan vasta
silloin, kun sen palauttama arvo on tarpeen. Laiska suoritus mahdollistaa muun muassa äärettömien
tietorakenteiden määrittelyn ja käsittelyn~\cite{cons76}, sillä Haskellin suoritusympäristö ei pyri
evaluoimaan niitä loppuun saakka, eikä ohjelma ei jää jumiin.

Yleisesti ottaen Haskell-komitean pyrkimys oli käyttää olemassa olevia ja hyvin tunnettuja
tekniikoita suunnittelutyönsä pohjana. Laiskuudesta oli noin vuosikymmenen verran kokemusta
Haskellin synnyn aikaan, joten se ei ollut uusi keksintö.

Laiskuus ei ole täysin ongelmaton valinta. Laiskan suorituksen on pidettävä kirjaa siitä, mitkä osat
ohjelmaa ovat suorittamatta, ja se kasvattaa yleiskustannuksia. Kirjanpidosta seuraava hidastus on
kuitenkin vakioinen ja verrattain pieni. Suurempi ongelma on se, että laiskan suorituksen
tilavaativuutta on vaikea arvioida ja se saattaa kasvaa ylilineaarisesti. Haskelliin on siksi
lisätty sekä tietorakenteita, jotka eivät ole laiskoja, että keino pakottaa lausekkeen evaluaatio,
jolloin laiskuuden voi poistaa sellaisesta kohdasta ohjelmaa, jossa se on haitaksi.

\subsection{Puhtaus}

Laiskuuden välitön seuraus on se, että evaluointijärjestys määräytyy tarpeen mukaan, jolloin
siirrännän ja muiden sivuvaikutusten käsittelyä on vaikeaa toteuttaa mielekkäästi. Haskell-komitean
ratkaisu oli tehdä Haskellista puhdas kieli, jolloin funktioilla ei ole lainkaan sivuvaikutuksia.
Tässä mielessä Haskellin funktiot ovat paitsi nimeltään niin myös merkitykseltään vastaavanlaisia
matemaattisten funktioiden kanssa -- molemmat palauttavat samalla syötteellä aina saman arvon. Tätä
ominaisuutta kutsutaan myös viitteelliseksi läpinäkyvyydeksi (engl. \emph{referential transparency})
ja siitä on apua, kun ohjelman toimintaa pyritään päättelemään ohjelmaa lukemalla.

Puhtauden vaikutukset ovat kaikenkattavat. Koska sivuvaikutuksia ei sallittu, oli siirräntä
Haskellin alkuaikoina tuskallisen hankalaa. Pakon edessä kehitettiin monadinen siirräntä, jota
voidaan pitää yhtenä Haskellin merkittävimmistä panostuksista ohjelmointikielten
kehitykselle~\cite{hoh07}. Keskustelu siitä, onko puhtaan kielen ja monadisten sivuvaikutusten
yhdistelmä paras lähestymistapa ohjelmistojen kehitykselle, on yhä kesken, mutta Haskellin tarjoama
ehdotus on ainakin elegantti ja mullistava. Lisäksi se on synnyttänyt paljon tutkimusta monadeista
ja tilan kapseloinnista.

\subsection{Tyyppiluokat}

Tyyppiluokkia pidetään nykyisin yhtenä Haskellin tunnusmerkillisimmistä ominaisuuksista. Alunperin
tyyppiluokat tuotiin osaksi kieltä, koska oli tarve ratkaista yhtäsuuruuden vertaamisen ja
numeeristen operaatioiden ylikuormitus. Haskell-komitean tavoite oli suunnitella kieli käyttäen
olemassa olevia ja perusteellisesti tunnettuja menetelmiä, mutta Haskellia edeltäneissä
funktionaalisissa kielissä, kuten Mirandassa tai Standard ML:ssä, ei ylikuormitusta oltu ratkaistu
yhtenäisellä tavalla~\cite{tcih96}. Lisäksi aiemmin käytetyissä menetelmissä oli tunnettuja
heikkouksia, jotka saattoivat johtaa ajonaikaisiin virhetilanteisiin.

Tyyppiluokat mahdollistavat nimensä mukaisesti tyyppien luokittelun sen perusteella, mitä
ylikuormitettuja operaatioita ne tukevat. Esimerkiksi Haskellissa luokkaan \code{Eq} kuuluvalle
tyypille on toteutettu yhtäsuuruusvertailu. Tällöin käännösvaiheessa on mahdollista tarkistaa, että
\verb|(==)|-operaattoria käytetään vain sellaisten tyyppien kesken, jotka kuuluvat
\code{Eq}-luokkaan. Vaikka tyyppiluokat olivat uusi keksintö eikä niiden toimivuutta oltu todistettu
aiemmin, Haskell-komitea päätyi omaksumaan ne osaksi kieltä, sillä niiden avulla kaikkien tyyppien
ylikuormitus oli ratkaistavissa yhtenäisellä, järjestelmällisellä ja modulaarisella tavalla.

Jälkikäteen ajateltuna tyyppiluokkien ottaminen osaksi Haskellia oli onnekas valinta, jolla on ollut
kauaskantoisia vaikutuksia, sillä tyyppiluokat ovat monikäyttöinen työkalu ja niiden avulla voi
tehdä paljon muutakin kuin toteuttaa ylikuormituksen. Yksi merkittävä edistysaskel Haskellin ja
tyyppiluokkien kehitykselle oli ehdotus tyyppimuodostajan parametroimisesta tyyppimuuttujan sijaan.
Tämä mahdollisti korkeamman asteen polymorfismin (engl. \emph{higher-kinded polymorphism}), mistä
oli pian hyötyä monadien toteuttamisessa~\cite{hoh07}.

\subsection{Syntaksi}

Koodiesimerkkejä ja -lainauksia käytetään jatkossa sekä ongelmien että ratkaisujen
havainnollistamiseen. Esimerkit mukailevat syntaksiltaan Haskellia silloinkin, kun ne ovat
pseudokoodia, joka ei käänny toimivaksi Haskell-ohjelmaksi. Listauksessa~\ref{lst:esittely}
esitellään syntaksi, jossa on kaksi osaa: funktion tyypin määrittely ja varsinainen funktion
määrittely.

\begin{lstlisting}[float,label={lst:esittely},caption={Syntaksin esittely}]
summa :: Int -> Int -> Int
summa x y = x + y
\end{lstlisting}

Tyyppimäärittely alkaa funktion nimellä, jonka jälkeen tulee kaksi kaksoispistettä, jota seuraa
mahdolliset parametrit ja paluuarvo eroteltuna nuolella (\verb|->|). Funktion määrittely alkaa myös
funktion nimellä, jota seuraa mahdolliset parametrit (tässä esimerkissä \code{x} ja \code{y}).
Funktion vartalo seuraa yhtäsuuruusmerkin jälkeen.

Kun erikoismerkeillä nimettyihin funktioihin viitataan tekstissä, funktion nimeen lisätään sulut
luettavuuden parantamiseksi. Esimerkiksi yhteenlaskuoperaattoria kutsutaan nimellä \verb|(+)|.


\section{Siirrännän vaikeus}

Haskellin kehityksen alkutaipaleella pohdittiin siirrännän toteuttamista ja siihen liittyviä
ongelmia. Valmista hyvänä pidettyä ratkaisua ei ollut olemassa, sillä olemassa olevien puhtaiden
funktionaalisten kielten siirräntää pidettiin epätyydyttävänä tai kielen muiden ominaisuuksien
suhteen oli tehty kompromisseja.

\subsection{Puhtaus}

Puhtaasta laskennasta on monia hyötyjä. Esimerkiksi rinnakkaista ohjelmointia pidetään perinteisesti
vaikeana, ja yksi merkittävä syy ohjelmointivirheille on se, että suorituksen eri haarat lukevat tai
muuttavat jaettua tilaa virheellisesti. Koska puhdas laskenta on sivuvaikutuksetonta, on se myös
immuuni rinnakkaisuuden yleisimmille ongelmille.

Sivuvaikutusten puute tarkoittaa myös sitä, että Haskell on viitteellisesti läpinäkyvä. Toisin
sanoen minkä tahansa Haskellin lausekkeen voi korvata kyseisen lausekkeen arvolla ilman, että
ohjelman merkitys muuttuu. Käytännössä viitteellinen läpinäkyvyys mahdollistaa optimoinnin, jossa
kääntäjä pelkistää kaikki toistuvat viitteet yhdeksi. Esimerkiksi listauksessa~\ref{lst:kuutio}
muuttujan \code{x} arvo täytyy selvittää vain kerran, jonka jälkeen saadulla arvolla korvataan
jokainen \code{x}:n ilmentymä ja kertolaskut voidaan laskea.

\begin{lstlisting}[float,label={lst:kuutio},caption={Puhdasta laskentaa}]
kuutio x = x * x * x
\end{lstlisting}

Esimerkin yksinkertaisuus saattaa hämätä, jonka vuoksi on syytä muistaa, että \code{x} voi olla
laskennallisesti mielivaltaisen haastava funktio ja optimointi voi olla merkittävä. Lisäksi
ilman puhtautta \code{x}:n arvo saattaisi olla riippuvainen esimerkiksi ulkoisesta syötteestä,
jolloin optimointia ei voisi tehdä yhtä huolettomasti. Toisaalta aina puhtaudesta johtuva
optimointi ei johda toivottuun lopputulokseen.

\begin{lstlisting}[float,label={lst:samat},caption={Kaksi samaa funktiota}]
lueKaksiRivia = { readLine; readLine }
\end{lstlisting}

Esimerkissä~\ref{lst:samat} käytetään kahdesti samaa funktiota, jonka tarkoitus on lukea käyttäjän
antama syöte. Jos puhtauden ja siirrännän ongelmaa ei ole ratkaistu, saattaa kääntäjä luottaa
puhtauteen sokeasti ja optimoida identtiset funktiot yhdeksi ja samaksi evaluaatioksi. Tällöin
käyttäjän syötteen luku tapahtuu vain kerran, sillä molempien funktioiden ilmentymä korvataan kerran
tehdyn evaluaation palauttamalla arvolla. Siirrännän käsittelyssä puhtaus ja sen seuraukset eivät
aina ole toivottavia.

\subsection{Laiskuus}

Laiska suoritus sopii hyvin yhteen puhtaan funktionaalisen kielen kanssa, mutta sekin tekee
siirrännän käsittelyn vaikeaksi. Listauksessa~\ref{lst:tulostus} on esimerkkiohjelma, jossa
määritellään funktio \code{sanoHaskell}, jonka tarkoitus on tulostaa merkkijono ``Haskell''
oletustulostusvirtaan.

\begin{lstlisting}[float,label={lst:tulostus},caption={Tulostava esimerkkiohjelma}]
sanoHaskell = print "Haskell"
\end{lstlisting}

Imperatiiviseen paradigmaan tottunut saattaisi olettaa, että ohjelma tulostaa toivotun merkkijonon
ja lopettaa. Laiska suoritus kuitenkin johtaa siihen, ettei mitään tulostu. Funktiota \code{print}
ei koskaan evaluoida, sillä sivuvaikutuksista ei välitetä eikä funktio palauta mitään sellaista
arvoa, joka on tarpeen ohjelman evaluaatiolle. Toisin sanoen tulostus optimoidaan kokonaisuudessaan
pois, vaikka tässä esimerkissä se on ohjelman ainoa varsinainen tarkoitus.

Laiskuuteen ja siirräntään liittyy myös toinen ongelma, joka on hieman hienovaraisempi.
Listauksen~\ref{lst:jarjestys} esimerkissä määritellään funktio \code{sanoHeiMaailma}, jonka on
tarkoitus suorittaa kaksi merkkijonon tulostusta. Imperatiivisissa ohjelmissa suoritus on
tavanomaisesti ahnetta ja ohjelman suoritus seuraa lähdekoodin rakennetta, mutta sama sääntö ei päde
laiskaan evaluointiin. Tästä seuraa se, ettei ole olemassa takeita siitä, missä järjestyksessä
esimerkkiohjelman tulostukset suoritetaan.

\begin{lstlisting}[float,label={lst:jarjestys},caption={Kahden tulostuksen pseudokoodi}]
sanoHeiMaailma = { print "Hei"; print " maailma" }
\end{lstlisting}

Toisin sanoen siinäkin tapauksessa, että tulostukset suoritettaisiin laiskuudesta huolimatta,
saattaa merkkijono ``maailma'' tulostua ennen merkkijonoa ``Hei''. Tämä on luonnollisesti merkittävä
ongelma, sillä lähes kaikissa käyttötapauksissa siirrännän tulee tapahtua määrätyssä järjestyksessä,
jotta ohjelma toimii tarkoituksenmukaisesti.

\subsection{Kohti imperatiivisuutta}

Listauksessa~\ref{lst:ratkaisu} on ohjelma, jonka käyttötarkoitus on sama kuin aiemmassa
listauksessa~\ref{lst:samat} eli ohjelman tulisi lukea syöte kahdesti, mutta toteutusta on
laajennettu siten, että puhtauden ja laiskuuden aiheuttamat ongelmat on pyritty ratkaisemaan.
Lisäksi tällä kertaa käytettyjen funktioiden tyyppimäärittelyt ovat kirjoitettu näkyviin.
Ratkaisussa on käytetty tekaistuja parametreja, joiden avulla suoritusjärjestys pakotetaan
halutunlaiseksi. Tekaistujen parametrien tyyppi ei ole tärkeä, ja listauksessa käytetty \code{Int}
on valittu vain yhtenä esimerkkinä kaikista mahdollisuuksista.

\begin{lstlisting}[float,label={lst:ratkaisu},caption={Suoritusjärjestys riippuvuuksien avulla}]
lueRivi       :: Int -> ( String,  Int)
lueKaksiRivia :: Int -> ([String], Int)

lueKaksiRivia p0 = ([s1, s2], p2) where
  (s1, p1) = lueRivi p0
  (s2, p2) = lueRivi p1
\end{lstlisting}

Funktio \code{lueKaksiRivia} palauttaa arvot \code{s1} ja \code{s2}, jotka edustavat niitä
merkkijonosyötteitä, joiden lukeminen on ohjelman varsinainen tavoite. Lisäksi ohjelma palauttaa
ylimääräisen arvon \code{p2}. Ohjelman toiminta on helpoin päätellä seuraamalla ohjelman suoritusta
käänteisessä järjestyksessä. Jotta \code{p2}:n arvo saadaan selville, on välttämätöntä suorittaa
funktio \code{lueRivi p1}. Jotta se voidaan suorittaa, täytyy saada selville arvo \code{p1}, joka
vuorostaan vaatii funktion \code{lueRivi p0} suorituksen ensin. Tällöin tekaistuilla parametreilla
on saavutettu se, että funktioilla \code{lueRivi} on muuttujien arvoon liittyvä riippuvuus, jolloin
laiska suoritus ei voi poimia suoritusjärjestystä mielivaltaisesti.

Samalla vältetään puhtaudesta juontuvat ongelmat. Funktioita \code{lueRivi p0} ja \code{lueRivi p1}
ei voi pelkistää yhdeksi evaluaatioksi, sillä ne käyttävät eri parametreja ja ovat siten
semanttisesti eri funktiot.

Funktion \code{lueKaksiRivia} saama parametri \code{p0} ei ole välttämätön tämän esimerkin kannalta,
mutta on tärkeä laajemmassa kontekstissa, sillä se mahdollistaa funktioiden koostamisen (engl.
\emph{function composition}). Jos funktiolle \code{lueRivi} ei voisi antaa mitään parametria, ei
puhtauden ja laiskuuden ongelmia olisi voitu ratkaista tekaistuilla parametreilla. Vastaavasti ilman
parametria \code{p0} olisi funktiolla \code{lueKaksiRivia} sama ongelma laajemman ohjelman
kontekstissa. Tästä syystä ei ole lainkaan sattumaa, että käytettyjen funktioiden tyyppimääritelmät
ovat hyvin samankaltaiset, sillä molempien funktioiden on tarkoitus toteuttaa siirräntää puhtaassa
ja laiskassa kielessä.

Vaikka tämän esimerkin ohjelman voi nähdä toimivan tarkoituksenmukaisella tavalla, on se samalla
muuttunut huomattavasti monimutkaisemmaksi. Ohjelma on vaikeaselkoinen, koska eri parametrien
tarkoitus ei ole ilmeinen, ja toisaalta tekaistujen parametrien käyttö ohjelman suorituksen
ohjaamiseen on semanttisesti ongelmallista.

\subsection{Tavoitteet}

Siirrännän toteuttaminen puhtaassa ja laiskassa kielessä ei ole itsestäänselvä asia, jonka vuoksi
jotkut funktionaaliset ohjelmointikielet ovat luopuneet puhtauden vaatimuksesta ja hyväksyneet
sivuvaikutukset osaksi siirrännän toteutusta. Koska Haskellin suunnittelun kulmakivi alusta alkaen
on ollut puhtaus ja laiskuus, on ratkaisun siirrännän toteuttamiseksi oltava yhteensopiva niiden
kanssa.

Ohjelmat ovat kokonaisuuksia, jotka syntyvät pienemmistä osatekijöistä. Funktionaalisten kielien
luonnollinen vahvuus on perinteisesti ollut se, että funktioita on helppo koostaa osaksi korkeamman
asteen funktioita (engl. \emph{higher-order function}). Haskellin siirrännän ratkaisun olisi tulisi
säilyttää tämä ominaisuus, jotta kielen käytettävyys tai ilmaisuvoima ei heikkene ohjelman tehdessä
siirräntää.

Lisäksi ratkaisun tulisi olla soveltuva ohjelmointikieleen yleisesti. Suotavia ominaisuuksia ovat
mm. ratkaisun yleishyödyllisyys ja laajennettavuus, tehokkuus ja toteutuksen helppous~\cite{ifp93}.
Toisin sanoen olisi kätevää, jos siirrännän haasteet olisivat ratkaistavissa siten, että samaa
mallia voisi soveltaa muihin Haskellin kipukohtiin. Ja niin kuin kaikkien ohjelmointiin liittyvien
ongelmien kanssa ei ratkaisu voi olla laskennallisesti liian vaativa tai sen käyttökelpoisuus
heikkenee.


\section{Kategoriateoria}

\subsection{Historia}

Alunperin kategoriateoria ja monadit tulivat osaksi tietojenkäsittelytiedettä vuonna 1989 Eugenio
Moggin julkaisun "Computational Lambda-calculus and Monads"~\cite{clcam89,nocam91} myötä. Moggi
tutki ohjelmointikieliä ja keinoja, joilla tietokoneohjelmista voidaan vetää loogisia
johtopäätöksiä, kuten esimerkiksi osoittaa kahden ohjelman yhdenmukaisuus.

Lambdakalkyyli oli aiemmin tarjonnut matemaattisen teoreettisen pohjan ohjelmien yhdenmukaisuuden
vertailuun. Lambdakalkyylin ei kuitenkaan ollut ongelmaton valinta, sillä se vaati ohjelman tai
proseduurin merkityksen pelkistämisen täydelliseksi funktioksi (engl. \emph{total function}).
Tällöin menetetään mahdollisuus tarkastella muun muassa pysähtyvyyttä, epädeterministisyyttä ja
sivuvaikutuksia, jotka ovat yleisiä oikeissa ohjelmissa.

Moggin valinta oli käyttää kategoriateorian tarjoamaa semanttista kehystä laskennan mallintamiseen.
Erityisesti Moggin innovaatio oli hyödyntää monadeja, joka mahdollisti ohjelmointikielen
ominaisuuksien jakamisen erillisiin osiin niiden semantiikan perusteella. Tällöin esimerkiksi
siirräntä, poikkeukset tai muut toisistaan poikkeavat ominaisuudet saivat oman erillisen kontekstin,
jossa niitä voitiin tarkastella.

Philip Wadler havaitsi, että Moggin käyttämä strategia rakenteen luomiseen semantiikan avulla
soveltuisi myös funktionaalisten ohjelmien jäsentämiseen~\cite{cm90,teofp92}. Toisin sanoen siinä
missä Moggi käytti monadeja ohjelmien kuvaamiseen, päätti Wadler hyödyntää monadeja ohjelmien
ilmaisemiseen.

\subsection{Kategoria}

Kategoriateoria on abstrakti matemaattinen työkalu, joka mahdollistaa monien matemaattisten
käsitteiden formalisoinnin. Kategoriateoreettinen lähestymistapa mahdollistaa erilaisten
matemaattisten rakenteiden -- kuten esimerkiksi joukkojen, ryhmien tai vektoriavaruuksien --
tarkastelun rakenteen säilyttävällä tavalla, jolloin kategorian tutkiminen sallii yhteisten
piirteiden kuvaamisen ja todistamisen.

Kategoria muodostuu kahdesta tekijästä, jotka ovat merkityksellisiä Haskellin näkökulmasta: olioista
ja morfismeista. Morfismeja (engl. \emph{morphisms}) kutsutaan myös nuoliksi (engl. \emph{arrow}),
mutta nuolella on Haskellissa eri merkitys, joten jatkossa pitäydytään nimityksessä morfismi.
Merkintä $f : A \rightarrow B$ tarkoittaa morfismia $f$ lähdeoliolta $A$ kohdeoliolle $B$ jossain
oletetussa kategoriassa.

Yhdiste (engl. \emph{composition}) on binäärioperaatio morfismeille siten, että jos samassa
kategoriassa on olemassa morfismit $f : A \arr B$ ja $g : B \arr C$, on oltava myös niiden
yhdistemorfismi $g \circ f : A \arr C$. Lisäksi morfismit noudattavat kahta sääntöä. Ensinnäkin
morfismien yhdisteen tulee olla assosiatiivinen eli:

$$f \circ (g \circ h) = (f \circ g) \circ h$$

Toiseksi missä tahansa kategoriassa $\mathcal{C}$ on olemassa jokaiselle oliolle $A$
identiteettimorfismi $1_A : A \arr A$. Tarkemmin sanottuna jokaiselle morfismille $f : A \arr B$
pätee:

$$ 1_A \circ f = f = f \circ 1_B $$

Miten sitten kategoriat liittyvät Haskelliin? Haskellin yhteydessä puhutaan usein kategoriasta
nimeltään \emph{Hask}, joka tarjoaa teoreettisen kehyksen ohjelmointikielen itsensä tarkasteluun.
Hask-kategorian kontekstissa Haskellin tyypit vastaavat kategoriateorian olioita ja funktiot
vastaavat morfismeja. Lisäksi funktiokompositio \verb|(.)| toimii Haskellissa yhdistemorfismina ja
funktio \code{id} toteuttaa identiteettimorfismin vaatimuksen.

Päällisin puolin näyttää siltä, että Haskellin ominaisuudet luovat suoraan kategorian siten kuin
kategoriateoria sen määrittelee. Tämä ei kuitenkaan pidä paikkaansa, sillä on olemassa rajatapauksia
erityisesti määrittelemättömien ja tyhjien arvojen kanssa, joissa Haskell ei käyttäydy
kategoriateorian sääntöjen mukaisesti. Sen sijaan ei ole väärin ajatella, että Haskell on omaksunut
vaikutteita kategoriateoriasta ja sen seurauksena Haskellin monadit ovat analogisia kategoriateorian
monadien kanssa.

\subsection{Monadi}

\begin{lstlisting}[float,float,label={lst:monad},caption={Monad-tyyppiluokka}]
class Applicative m => Monad m where
  (>>=)  :: forall a b. m a -> (a -> m b) -> m b
  (>>)   :: forall a b. m a -> m b -> m b
  return :: a -> m a
\end{lstlisting}

Monadi on yksi kategoriateorian yleisimmin hyödynnetyistä rakenteista, joka on osoittautunut
monikäyttöiseksi työkaluksi myös ohjelmointikieliä tarkasteltaessa. Erityisesti funktionaalisten
kielien tapauksessa monadit sallivat laskennan kuvaamisen riittävän abstraktilla tavalla, jotta ne
ovat päätyneet ratkaisemaan lukuisia käyttötapauksia. Pelkästään Haskellin standardikirjasto tarjoaa
monadeihin tukeutuvia työkaluja paitsi siirrännän niin myös tilan, virheenkäsittelyn ja
epädeterministisen laskennan tarpeisiin.

Monadit ovat toteutettu Haskellissa tyyppiluokkana. Listauksessa~\ref{lst:monad} on lainaus
Haskell-kääntäjän \emph{GHC} (Glasgow Haskell Compiler) lähdekoodista, josta on nähtävissä
\code{Monad}-luokka ja tyyppimääritelmät sen kolmelle metodille (eli luokan funktiolle). Yksittäiset
tyypit, joille periytetään monadin ominaisuudet, määrittelevät tarkoitukseensa sopivan toteutuksen
vaadituille metodeille.

Jotta luotu tyyppi käyttäytyy oikean monadin tavoin, täytyy metodien toteutuksen seurata kolmea
sääntöä, joita kutsutaan monadilaeiksi (engl. \emph{monad laws})~\cite{teofp92}. Säännöt pitävät
huolta siitä, että monadien yhdisteet toimivat assosiatiivisesti ja että metodit säilyttävät
toimintojen samuuden. Haskellin ilmaisuvoima ei riitä siihen, että kääntäjä pystyisi muodollisesti
todistamaan jonkun tyypin täyttävän monadilait, joten se jää ohjelmoijan vastuulle.

\subsection{Monadin toteutus}

Mitä monadiin kuuluvat funktiot sitten tekevät? Ensimmäinen niistä on \verb|(>>=)|, joka luetaan
\emph{bind} tai suomeksi \emph{sidos}. Kuten nimi antaa ymmärtää sidoksen avulla yhdistetään
toiminto ja funktio. Tyypillisesti sidosta käytetään sisämerkintänä argumenttiensa välissä.
Esimerkiksi $a >>= f$ tarkoittaa, että toimisto \code{a} ja funktio \code{f} ketjutetaan yhteen
siten, että evaluaation aikaan toiminto \code{a} suoritetaan, sen paluuarvo sovelletaan funktioon
\code{f}, josta saadaan koko lauseen paluuarvo.

Toinen monadin funktio \verb|(>>)| luetaan \emph{then}, jonka voi kääntää suomeksi \emph{sitten}. Se
toimii muutoin kuten sidos, mutta se ei välitä paluuarvoa ensimmäiseltä toiminnolta. Toisin sanoen
sitä voi käyttää yhdistämään toimintoja, joiden paluuarvoilla ei ole merkitystä. Jos tarkkoja ollaan
\verb|(>>)| ei ole pakollinen toimivan monadin toteuttamiseksi, mutta käytännön ohjelmoinnin ja
koodin selkeyden näkökulmasta se on hyödyllinen.

Useissa imperatiivisissa ohjelmointikielissä tunnetaan avainsana \code{return}, jonka tarkoitus on
keskeyttää aliohjelman suoritus ja palauttaa jokin arvo. Haskellissa \code{return} on funktio, joka
nostaa argumenttinsa monadin kontekstiin. Toisin sanoen \code{return a} evaluoituu monadiseksi
tyypiksi, joka pitää sisällään arvon \code{a}. Funktion \code{return} nimi on valitettava sillä se
aiheuttaa paljon hämmennystä uusien Haskellin harrastajien keskuudessa.

\subsection{Toimiva ohjelma}

Listauksessa~\ref{lst:then} on päivitetty versio luvun~\ref{subsec:laiskuus} esimerkistä. Ohjelmaa
on muutettu siten, että tulostustoiminnot ovat yhdistetty \emph{then}-funktiolla, jonka lisäksi
tyyppimääritelmä on kirjoitettu näkyviin sen korostamiseksi, että toiminnot ovat suoritettava
IO-monadin kontekstissa. Tällä kertaa ohjelma on täysin toimiva ja se tulostaa merkkijonot
toivotulla tavalla.

\begin{lstlisting}[float,label={lst:then},caption={Toimiva tulostus}]
sanoHeiMaailma :: IO ()
sanoHeiMaailma = putStr "Hei" >> putStr " maailma"
\end{lstlisting}

Päällepäin katsottuna ei kuitenkaan ole ilmeistä, kuinka ohjelma eroaa listauksesta
\ref{lst:jarjestys}. Näemme että ohjelma hyödyntää \code{then}-funktiota, mutta mikä mekanismi pitää
huolta, että tulostukset ylipäätään tapahtuvat. Ja onko ohjelma yhä puhdas ja viitteellisesti
läpinäkyvä?


\section{Siirrännän toteutus}

\subsection{IO-monadi}

Siirräntää varten Haskelliin on lisätty \code{IO}-tyyppi, joka joka ilmaisee toimintoa. \code{IO} on
yhdistelmätyyppi (engl. \emph{algebraic data type}), joka ottaa parametrikseen toisen tyypin, joka
ilmaisee toiminnon paluuarvon tyyppiä. Esimerkiksi funktio tyyppiä \code{IO Int} voi suorittaa
siirräntää ja palauttaa sen jälkeen kokonaislukuarvon.

\code{IO}-tyypille on myös määritelty \code{Monad}-tyyppiluokan ilmentymä, joka tarkoittaa sitä,
että \code{IO}-tyypille on määritelty monadiset operaatiot \emph{bind}, \emph{then} ja
\code{return}. Koska siirrännän toimiminen vaatii monadin ominaisuudet ja ne ovat \code{IO}:n
leimallinen piirre, on tavallista puhua \emph{IO-monadista} IO-tyypin sijaan.

Samoin kuin monet aiemmat funktionaaliset ohjelmointikielet, myös Haskell käyttää
\emph{Hindley--Milner-tyyppijärjestelmää}~\cite{hoh07}. Haskellissa on myös alusta alkaen ollut
tyyppiluokat osana kielen ilmaisuvoimaa. Kun IO-monadi päätettiin lisättiin Haskelliin 90-luvun
alussa, oli se teknisessä mielessä verrattain helppo operaatio, sillä monadit olivat luonteva
toteuttaa tyyppiluokkien avulla ja \code{IO}-tyyppi soveltui Hindley--Milner-järjestelmään
sellaisenaan.

\subsection{Toiminto ja suoritus}

Funktionaalisessa kielessä lauseke ilmaisee arvoa, kun taas siirräntä on luonteeltaan suorite, joka
tulisi toteuttaa. Osana siirrännän ratkaisua on Haskellissa erotettu olemassa oleminen ja tekeminen
toisistaan~\cite{ifp93}. Tätä jakoa edustaa IO-monadi, joka on toiminto (engl. \emph{action}) ja
jonka suoritus (engl. \emph{perform}) voi toteuttaa siirräntää ja palauttaa arvon. Jatkossa
\emph{toiminto} tarkoittaa aina \code{IO}-tyyppistä funktiota.

Erottelemalla toiminto suorittamisesta \code{IO}-tyyppiset funktiot kapseloivat siirrännän siten,
että ne ovat yhteensopivat Haskellin puhtaan funktionaalisen paradigman kanssa säilyttäen
viitteellisen läpinäkyvyyden. Toisin sanoen toiminnot ovat tavallisia funktiota, joita voidaan
välittää argumenttina, koostaa osaksi korkeamman asteen funktioita ja yleisesti ottaen käsitellä
kuten mitä tahansa Haskellin funktiota.

\subsection{Siirrännän esimerkkiohjelma}

\begin{lstlisting}[float,label={lst:ioprog},caption={IO-ohjelma ja sen evaluaatio}]
main :: IO ()
main = getChar >>= putChar

getChar :: IO Char
putChar :: Char -> IO ()
(>>=)   :: IO a -> (a -> IO b) -> IO b

1. (>>=) getChar putChar
2. (IO a -> (a -> IO b) -> IO b) getChar putChar
3. (IO Char -> (Char -> IO b) -> IO b) (IO Char) putChar
4. ((Char -> IO b) -> IO b) putChar
5. ((Char -> IO ()) -> IO ()) (Char -> IO ())
6. IO ()
\end{lstlisting}

Listauksessa~\ref{lst:ioprog} on kolme osaa. Kahdella ensimmäisellä rivillä on esimerkkiohjelma,
joka lukee merkin vakiosyötteestä ja tulostaa sen vakiotulosteeseen. Ohjelma käyttää toimintoja
\code{getChar}, \code{putChar} ja \verb|(>>=)|, joiden tyypit ovat kirjoitettu näkyviin.
\code{getChar} on toiminto, joka palauttaa \code{Char}-tyyppisen arvon. Vastaavasti \code{putChar}
on toiminto, joka ottaa \code{Char} arvon parametrinaan ja palauttaa tyhjän IO-toiminnon eli
\code{IO ()}. Haskellissa tyhjät sulkeet merkitsevät olematonta arvoa ja niiden käyttö tässä
yhteydessä on välttämätöntä, sillä IO-tyyppi vaatii tyyppiparametrin.

Listauksen lopussa käydään esimerkkiohjelman evaluaatio läpi vaihe vaiheelta ohjelman käyttämien
tyyppien avulla. Evaluaation ensimmäisellä rivillä ohjelma on muutoin muuttumaton, mutta
\verb|(>>=)| funktio on siirretty sisämerkinnästä parametriensa eteen, jotta esimerkkiä olisi
helpompi seurata myöhemmin.

Toisella rivillä \verb|(>>=)| on korvattu tyyppimääritelmällään. Tässä vaiheessa IO-tyyppi on vielä
polymorfisesssa muodossa, sillä lopullista tyyppiä ei vielä tiedetä. Toisin sanoen merkinnässä
käytetään yhä \code{a} ja \code{b} -tyyppiparametreja.

Kolmannella rivillä \code{getChar} on korvattu tyypillään ja samalla huomaamme että sen tyyppi sopii
sidosfunktion ensimmäisen parametrin tyyppiin, jos tyyppiparametri \code{a} saa arvon \code{Char}.
Tarkennamme tyyppimääritelmiä korvaamalla \code{IO a} -merkinnän tyypillä \code{IO Char}.

Neljännellä rivillä sievennämme lauseketta soveltamalla \code{getChar}-funktion ja poistamme sen
merkinnöistä. Tässä vaiheessa Haskell-ohjelman evaluaatiota tapahtuu toiminnan suoritus, joten
voimme olettaa, että tiedämme paitsi tyypin niin myös paluuarvon \code{getChar}-funktiolle.

Viidennellä rivillä \code{putChar}-funktio korvataan tyypillään ja voimme jälleen tehdä
tyyppipäättelyn samalla tavalla kuin kolmannella rivillä. Huomaamme että tyyppiparametrin \code{b}
tyypiksi sopii \code{()}. Lisäksi tiedämme arvon parametrille \code{Char}, joten
\code{putChar}-funktion soveltaminen on mahdollista. Tällöin tapahtuu myös toisen toiminnon
suoritus.

Tässä vaiheessa alkuperäisestä sidosfunktiosta on jäljellä enää toinen parametri ja paluuarvo.
Kuudennella rivillä funktio \code{putChar} on sovellettu sidosfunktioon ja jäljelle jää enää
paluuarvon tyyppi \code{IO ()}, joka vastaa koko ohjelman tyyppiä.

Siirrännän lisäksi tämä esimerkki kattaa monta yleistä funktionaalisen kielen ominaisuutta, jotka
ovat syytä mainita selkeyden vuoksi. Ohjelman sieventäminen tyyppien avulla on vastaavanlainen
operaatio kuin kääntäjän tekemä tyyppipäättely Haskell-ohjelmaa käännettäessä. Esimerkin
sieventyminen tyypiksi \code{IO ()} ei ole sattuma, sillä se on vaatimus kaikille
Haskell-ohjelmille, sillä kaikkien omavaraisten Haskell-ohjelmien suoritus on sidottu
\code{main}-funktioon, jonka tyyppi on \code{IO ()}.

Toinen merkittävä funktionaaliseen kieleen liittyvä havainto on se kuinka ohjelmaa suoritetaan.
Imperatiivisessa kielissä suoritus yleensä koostu toisistaan riippumattomien lauseiden ajamisesta
siten, että suorituksen järjestys määräytyy ensisijaisesti lauseiden järjestyksestä lähdekoodissa.
Sen sijaan funktionaalisen kielen ohjelma on itsessään funktio, joka muodostuu pienemmistä
funktioista. Ohjelman suoritus on sieventämistä, joka tapahtuu funktioita soveltamalla ja
suoritusjärjestys ohjautuu kielen sievennyssääntöjen mukaisesti.

\subsection{Toimintojen yhdistäminen}

Siirräntä ei ole triviaalia puhtaassa ja laiskassa ohjelmointikielessä, sillä kieli itsessään ei
määrittele missä järjestyksessä siirräntä tulee suorittaa eikä edes sitä, suoritetaanko sitä
ollenkaan. Itse asiassa päin vastoin Haskellin määritelmä sanoo, että kieli on löyhä
evaluaatiojärjestyksestään (engl. \emph{non-strict evaluation semantics}). Monadit, ja tässä
tapauksessa erityisesti IO-monadi, ratkaisevat toimintojen suoritusjärjestyksen ongelman siten, että
monadiset operaatiot liittävät toiminnot yksiselitteisesti osaksi evaluaatiojärjestystä.

Edellisessä esimerkkiohjelmassa \code{getChar}-funktio suoritettiin ennen \code{putChar}-funktiota,
sillä \code{putChar} vaati argumentikseen \code{getChar}-funktion paluuarvon. Suoritus ei olisi
voinut tapahtua käänteisessä järjestyksessä, sillä näiden kahden toiminnon välillä on
yksikäsitteinen riippuvuus, joka luotiin \verb|(>>=)|-metodin avulla. Evaluaatiojärjestyksen
takaaminen on yksi IO-monadin tärkeistä ominaisuuksista.

Toinen merkittävä IO-monadin tehtävä on, että se tarjoaa viitekehyksen, joka tekee siirrännän
yhdistämisestä Haskell-ohjelmiin verrattain helppoa ja ymmärrettävää. Vaikka siirrännän
esimerkkiohjelma oli hyvin lyhyt, sen perusteellinen läpikäynti paljasti monisärmäisen rakennelman,
jonka ymmärtäminen edellyttää kattavan teoreettisen tietopohjan. Siitä huolimatta on
perusteltavissa, että

$$ getChar >>= putChar $$

on sekä yksinkertainen että intuitiivinen ilmaisu sille, että merkin luku- ja kirjoitusoperaatiot
tulisivat tapahtua peräjälkeen. Toisin sanoen, vaikka Haskellin juuret ovat syvällä
kategoriateoriassa, ohjelmoijan harteille ei ole sysätty kognitiivista kuormaa pitää mielessä
IO-monadin yksityiskohtia päivittäisessä ohjelmointityössään.

\subsection{Imperatiivinen tyyli}

Imperatiivinen ohjelmointimalli soveltuu hyvin siirräntään, sillä imperatiivisen koodin rakenne ja
ohjelman semantiikka vastaavat toisiaan. Haskelliin on siksi lisätty \verb|do|-merkintätapa (engl.
\emph{do-notation}), joka mahdollistaa Haskell-ohjelmakoodin kirjoittamisen imperatiiviseen tyyliin,
mutta hyödyntäen monadeja ja funktionaalista semantiikkaa. Do-merkintätapa on syntaktista sokeria,
joten se ei lisää eikä vähennä Haskellin kielellistä ilmaisuvoimaa.

Do-merkintätapa lisää Haskelliin avainsanat \code{do} ja \verb|<-|. Avainsana \code{do} aloittaa
koodilohkon, joka rajataan ympäröivästä ohjelmasta sisentämällä, ja jonka kontekstissa kääntäjä
pelkistää (engl. \emph{desugar}) rivinvaihdot monadisiksi yhdistefunktioiksi. Samalla tavalla kuin
usein imperatiivisissa ohjelmissa rivi merkitsee yhtä itsenäistä ilmaisua, \code{do}-lohkossa rivi
vastaa yhtä toimintoa.

Avainsana \verb|<-| luetaan \emph{bind} tai \emph{sidos}. Nimi on sama kuin metodilla \verb|(>>=)|,
sillä molemmat suorittavat samaa monadista tehtävää eli sitovat toiminnosta tulleen paluuarvon. Ne
eivät kuitenkaan ole täysin identtiset, sillä siinä missä \verb|(>>=)| välittää paluuarvon
seuraavalle toiminnolle, \verb|<-| ottaa paluuarvon ja antaa sille nimen, jota voidaan käyttää
laskennassa myöhemmin.

Do-notaatio lienee helpoin hahmottaa esimerkin avulla. Listauksessa~\ref{lst:desugared} on
esimerkkiohjelma, joka kysyy käyttäjän nimeä, lukee syötteen ja tulostaa tervehdyksen. Koska alussa
tapahtuva tulostus ei palauta merkityksellistä arvoa, käytetään funktiota \code{then} yhdistämään
toimintoja. Sen sijaan \code{getLine} palauttaa merkkijonon, joten sen paluuarvo välitetään
eteenpäin \emph{sidoksen} avulla. Esimerkin viimeisellä rivillä on nimetön funktio, jota kutsutaan
myös \emph{lambdaksi}. Se ottaa parametrikseen \code{getLine}-funktiolta tulleen merkkijonon, antaa
sille nimen \code{nimi} ja tulostaa tekstiä käyttäen saamaansa parametria.

\begin{lstlisting}[float,label={lst:desugared},caption={Funktionaalinen tyyli}]
main :: IO ()
main = putStrLn "Mikä on nimesi?"
       >>
       getLine
       >>=
       \nimi -> putStrLn ("Hei " ++ nimi ++ "!")
\end{lstlisting}

Vaikka sama ohjelma on mahdollista kirjoittaa käyttämättä lambda-ilmaisua, voidaan sen avulla antaa
nimi funktion \code{getLine} paluuarvolle. Vastaavasti paluuarvon nimeäminen ei ole välttämätöntä,
mutta ohjelmoitaessa tulee jatkuvasti vastaan tilanteita, joissa asioiden nimeäminen on hyödyllistä,
jotta niihin on helppo myöhemmin viitata tai jotta koodi pysyy helpommin luettavana ja
ymmärrettävänä.

Listauksessa~\ref{lst:donotation} on sama ohjelma, mutta tällä kertaa se on kirjoitettu
do-merkintätapaa käyttäen. Do-merkintätavan takia monadisia sidosfunktioita ei tarvitse kirjoittaa
täsmällisesti näkyviin, sillä kääntäjä päättelee niiden tarpeen rivinvaihtojen ja \verb|<-|-sidoksen
perusteella. Toiminnon \code{getLine} palauttama arvo sidotaan \verb|<-|:lla nimeen syntaksilla,
joka on samankaltainen verrattuna minkä tahansa imperatiivisen ohjelmointikielen tapaan tallentaa
arvo johonkin muuttujan.

\begin{lstlisting}[float,label={lst:donotation},caption={Imperatiivinen tyyli ja do-merkintätapa}]
main :: IO ()
main = do
  putStrLn "Mikä on nimesi?"
  nimi <- getLine
  putStrLn ("Hei " ++ nimi ++ "!")
\end{lstlisting}

Ilman \emph{do}-merkintää paluuarvon nimeäminen vaati selkeästi monimutkaisemman ilmaisun ja vaati
ylimääräisen anonyymin funktion käyttöä. Sen sijaan jäljemmässä esimerkissä toiminto ja sen
paluuarvon nimeäminen tapahtuvat luontevasti samalla rivillä. Yleisesti ottaen \emph{do}-merkintä
tarjoaa syntaksin, joka on intuitiivinen ja ennestään tuttu lähes mitä tahansa muita
ohjelmointikieliä käyttäneille, mutta jonka avulla on helppo hyödyntää Haskellin ja funktionaalisen
ohjelmoinnin ominaisuuksia kuten tyyppipäättelyä ja -turvallisuutta, funktioiden tarjoamaa
modularisuutta, laiskuutta ja puhtautta.

\subsection{Oikea maailma}

Aiemmin on mainittu IO-monadin luoma viitekehys ja se, että monadiset operaatiot -- erityisesti
\verb|(>>=)| -- ratkaisevat laiskuuteen ja laskennan järjestykseen liittyvät haasteet. Mutta mikä
mekanismi tarkalleen ottaen määrää evaluaatiojärjestyksen? Osa vastausta on ollut omaksua ajatus
Haskell-ohjelman ulkopuolisesta maailmasta osaksi Haskellin semantiikkaa. Toisin sanoen
Haskell-kääntäjä tuntee konseptin oikeasta maailmasta. Oikeaa maailmaa kutsutaan Haskellin
kontekstissa joskus nimellä \emph{RealWorld}, mutta jatkossa käytetään typistettyä nimitystä
\emph{World}.

\begin{lstlisting}[float,label={lst:world},caption={IFP, IO-tyyppi}]
type IO a    = World -> IORes a
data IORes a = MkIORes a World
\end{lstlisting}

Ohjelman ulkopuolisen maailman ottaminen huomioon ohjelmointikielen tasolla voi vaikuttaa ylettömän
korkealentoiselta, mutta tosiasiassa se auttaa ratkaisemaan puhtauteen liittyvät ongelmat.
Listauksessa~\ref{lst:world} on ote julkaisusta Imperative Functional Programming\cite{ifp93}, johon
Haskellin IO-monadin toteutus pohjautuu. Määrittelyssä käytetyn tyyppialiaksen sovelmisen jälkeen
IO-tyypin määritelmä saadan yksinkertaistettua muotoon:

$$ IO\; a = World \arr (a,\; World) $$

IO on siis yhdistelmätyyppi ja funktio, jonka parametri on maailma ja arvo on pari, joka koostuu
toiminnon paluuarvosta ja maailmasta. Käsitteellisesti siis Haskell-ohjelman toiminto ottaa
syötteekseen koko tunnetun maailman ja palauttaa uuden maailman, jonka tilaa on muutettu kyseisen
toiminnon verran. Ajatus voi vaikuttaa hieman liioitellulle, mutta se on yhteensopiva viitteellisen
läpinäkyvyyden kanssa, joka vastaavasti on kriittinen vaatimus puhtauden säilyttämiseksi.

Tietysti koko tunnetun maailman muunnos on laskennallisesti liian mahtipontinen suorite, joten
\emph{World} on vain abstrakti tietotyyppi. Tämä tarkoittaa sitä, että toisaalta \emph{World} on
Haskell-kääntäjälle todellinen, sillä sitä käytetään lähdekoodissa IO-monadia määriteltäessä, mutta
toisaalta \emph{World} ei koskaan päädy käännettyyn Haskell-ohjelmaan eikä se näy Haskell-ohjelmassa
ajon aikana, sillä se optimoituu pois käännösvaiheessa.

\begin{lstlisting}[float,label={lst:bindio},caption={IFP, bindIO:n määritelmä}]
bindIO m k w = case (m w) of
  MkIORes a w' -> k a w'
\end{lstlisting}

Ennen kuin kääntäjä poistaa kyseisen abstraktion on sillä konkreettinen tehtävä toimintojen
ketjuttamisessa. Listauksessa~\ref{lst:bindio} on \code{bindIO}-funktion määritelmä~\cite{ifp93},
joka on käytännössä toteutus sidosfunktiolle \verb|(>>=)|. \code{bindIO}:n argumentit ovat monadiset
toiminnot (\code{m} ja \code{k}) sekä \emph{World} (\code{w}). Ensimmäinen toiminto suoritetaan
yhdessä maailman tilan kanssa ja tulos sovitetaan IO-paluuarvoksi \code{a} ja uudeksi maailman
tilaksi \code{w'}. Sovituksen onnistuessa uusi maailman tila palautetaan muiden paluuarvojen mukana.

Kun abstraktia maailman tilaa kuljeteteaan siirräntätoimintojen mukana läpi Haskell-ohjelman,
saadaan aikaan suoraviivainen linkitetty toimintojen ketju. Tarkemmin ilmaistuna \emph{World} luo
tietoriippuvuuden (engl. \emph{data dependency}) kaikkien ohjelman toimintojen välille jokaisen
toiminnon sekä kuluttaessa että palauttaessa maailman tilan. Koska ketjun aiemman toiminnon
paluuarvoa tarvitaan ketjun seuraavan toiminnon toteutukseen, on Haskell-ohjelman välttämätöntä
evaluoida toiminnot järjestyksessä.

Tässä vaiheessa voimme palauttaa mieleen listauksessa~\ref{lst:ratkaisu} olleen esimerkkiohjelman.
Siinä toimintojen järjestyksen ongelma ratkaistiin luomalla ylimääräiset kokonaislukuparametrit,
joita välittämällä suoritus pakotettiin toivottuun järjestykseen. IO-monadi ja sen kontekstissa
käytetty abstrakti \emph{World} ovat loogisesti sama ratkaisu laiskuuden tarjoamaan haasteeseen.
Oleellinen ero on, että monadi kätkee toteuksen siten, ettei se kuormita ohjelman syntaksia. Lisäksi
kääntäjän on mahdollista optimoida abstrakti tietotyyppi pois hidastamasta valmiin ohjelman
suoritusta.

\subsection{Pääohjelma}

Monadien tarjoama viitekehys auttaa ratkaisemaan laiskuuteen ja laskennan järjestykseen liittyvät
haasteet, mutta siirräntä on silti konseptuaalisesti vaikea asia Haskellille. Siirräntä on ennen
kaikkea sivuvaikutusten aiheuttamista, mutta Haskell on puhdas ja puhtaus tarkoittaa sivuvaikutusten
välttämistä. Ristiriita on ilmeinen. Mikä siis pakottaa Haskell-ohjelman toteuttamaan siirräntää
ylipäätään?

Haskellin ratkaisu on määritellä koko ohjelma toiminnoksi nimeltään \code{main}, jota voidaan kutsua
pääohjelmaksi. Pääohjelman tyyppi on \code{IO ()} ja sen suoritus vastaa koko ohjelman
suorittamista. Funktionaalisesta semantiikasta johtuen Haskell-ohjelma on mielivaltainen joukko
matalamman tason toimintoja, jotka ovat ketjutettu yhteen monadisilla operaatioilla pääohjelman
tyypin takia. Toisin sanoen jotta koko ohjelman voi suorittaa, on seurattava toimintojen
riippuvuusketjua ja evaluoitava järjestyksessä ketjun kaikki toiminnot.

Siirrännän tyyppiturvallisuus on taattu pääohjelman tyyppimäärittelyllä ja sillä, ettei Haskell
salli suoraa pääsyä IO-tyypin parametriin eli siirränään paluuarvoon. Toisin sanoen pääohjelma
määrää koko ohjelman arvon IO-tyyppiseksi ja kaikki pääohjelmalle alisteiset toiminnot joutuvat
käsittelemään siirrännän paluuarvoja IO-monadin kontekstissa, sillä monadista pakenemiselle ei ole
tarjolla helppoa mekanismia.

Pääohjelman käsite on yleinen myös imperatiivisissa ohjelmointikielissä, joissa sitä käytetään
suorituksen lähtöpisteenä. Haskellin \code{main} vastaa intuitiivisesti imperatiivisten kielien
pääohjelmaa, mutta tarkemmin tarkasteltuna ero on merkittävä. Voidaan ajatella että
funktionaalisuuden takia pääohjelma ei niinkään ole suorituksen alkupiste vaan pikemminkin
evaluaation loppupiste, sillä Haskell-ohjelman sieventää itseään kunnes lopulta saavutetaan
\code{main}-toiminnon paluuarvo.


\section{Yhteenveto}

Kun Haskell sai alkunsa 80- ja 90-lukujen vaihteen aikaan, ei ollut olemassa valmista mallia sille,
kuinka sovittaa siirräntä yhteen funktionaalisen, puhtaan ja laiskan ohjelmointikielen kanssa.
Toimiva, tehokas ja helppokäyttöinen malli siirrännälle on kuitenkin kriittinen vaatimus mille
tahansa vakavasti otettavalle ja yleiskäyttöiselle ohjelmointikielelle.

Siirrännän toteutukselle oli tarjolla muutama eri vaihtoehto, joista kategoriateorian monadeista
inspiraationsa saanut malli valikoitui voittajaksi. Nykyisin Haskellin siirrännän toteutus hyödyntää
monadien tarjoamaa abstraktiota, jotta puhtauden ja siirrännän ristiriita voidaan ratkaista
jakamalla siirräntä toimintoihin ja niiden suoritukseen. Toiminnot soveltuvat kieleen hyvin, sillä
tyyppitarkastus ja yhdistäminen toimii niille samalla tavalla kuin mille tahansa muulle funktiolle.

IO-monadin toteuttaminen osaksi Haskellia oli verrattain vaivatonta, sillä tyyppiluokat olivat jo
aiemmin yksi Haskellin ominaisuuksista, ja monadit ovat helposti toteutettavissa tyyppiluokkien
avulla. Haskelliin on myös lisätty \verb|do|-merkintätapa, joka mahdollistaa monille ohjelmoijille
tutun imperatiivisen tyylin käyttämisen siirrännän ohjelmoimiseen monadien avulla.

Siirrännän toteutus monadien avulla ei ole ristiriidassa kielen muiden ominaisuuksien kanssa, joten
esimerkiksi puhtaus ja laiskuus säilyvät Haskellille leimallisina ominaisuuksina. Monadit ovat myös
yhteensopivat käytössä olevan tyyppijärjestelmän kanssa, joten kääntäjän on helppo taata ohjelmien
tyyppiturvallisuus. Monadinen siirräntä on myös suorituskykyinen ratkaisu, sillä toimintojen
ketjuttamiseen tarvittavat abstraktiot voidaan poistaa käännösaikana, mikä mahdollistaa kääntäjälle
tehokkaan konekielen tuottamisen.

Siirrännän lisäksi monadit on otettu Haskellissa käyttöön monissa muissakin sovelluksissa, joissa
puhtaus ja laiskuus ovat näennäisesti ristiriidassa kaivatun käyttötapauksen kanssa. Esimerkiksi
\code{State}-monadi sallii tilatiedon ylläpitämisen, joka ei tavallisesti olisi mahdollista
puhtauden takia. Näin ollen siirrännän ratkaiseminen, joka oli eräs merkittävistä haasteista
Haskellin kehityksen alkuaikona, on vaikuttanut merkittävällä tavalla kielen kehitykseen myös
myöhempinä vuosina.

\bibliographystyle{babalpha-lf}
\bibliography{viitteet}

\end{document}

\documentclass[finnish]{tktltiki2}
% vim: set textwidth=100 :
% rubber: module pdftex

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

\usepackage{listings}
\renewcommand{\lstlistingname}{Listaus}
\lstset{captionpos=b,frame=single,language=Haskell,literate={ä}{{\"a}}1}

\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

\usepackage[nottoc]{tocbibind}
\settocbibname{Lähteet}

\title{Haskell ja monadinen imperatiivisuus}
\author{Tuomas Starck}
\date{\today}
\level{Referaatti}
\abstract{Referaatti.}

\keywords{haskell}

% \classification{}

\begin{document}

\frontmatter

\maketitle
\makeabstract

\tableofcontents

\mainmatter

\newcommand{\arr}[0]{\rightarrow}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\fixme}[1]{\emph{#1}}


\section{Johdanto}

% Jäsennelty asianmukaisesti (kenelle, miksi, millaisessa ympäristössä; ratkaisun lähestymistapa;
%  tutkimuskysymys, tulokset ja impakti; loppulukujen roolitus), pituus 1,5 - 2 s.
% Esim:
% 1.1 Peliteoria ja pelipuu
% 1.2 Minimax ja heuristiikka

\fixme{Kirjoita oikea johdanto eli mitä teksti käsittelee}


\section{Historiaa evt}

\fixme{Nää kappaleiden nimet pitää funtsia uusiksi, tämä on joku Haskellin esittely vissiin}

\subsection{Haskell}

Haskell sai alkunsa vuonna 1987 Functional Programming and Computer Architecture -konferenssin
yhteydessä pidettyssä tapaamisessa, jossa päätettiin suunnitella ja kehittää uusi ohjelmointikieli.
Ennen Haskellia oli olemassa lukuisia funktionaalisia ohjelmointikieliä, mutta vaihtoehtojen
ylitarjonta sipraloi funktionaalisen ohjelmoinnin kentän ja hidasti sen edistystä. Kielen
kehittämistä varten perustettiin komitea, jonka tavoitteena oli luoda yksi yhtenäinen
funktionaalinen ohjelmointikieli. Komitean yksi ensimmäisistä saavutuksista oli uuden kielen
nimeäminen Haskelliksi.

\subsection{Laiskuus}
\label{subsec:laiskuus}

Haskell-komitean merkittävin yhteinen tavoite oli tehdä Haskellista laiska. Laiskuudella
tarkoitetaan sitä, että ohjelman lausekkeet evaluoidaan vasta silloin, kun niiden palauttama arvo on
tarpeen. Laiska suoritus mahdollistaa muun muassa äärettömien tietorakenteiden määrittelyn ja
käsittelyn, sillä Haskellin suoritusympäristö ei pyri evaluoimaan niitä loppuun saakka, joten
ohjelma ei jää jumiin.

Yleisesti ottaen Haskell-komitean pyrkimys oli käyttää olemassaolevia ja hyvin tunnettuja
tekniikoita suunnittelutyönsä pohjana. Laiskuudesta oli noin vuosikymmenen verran kokemusta
Haskellin synnyn aikaan, joten se ei ollut uusi keksintö.

Laiskuus ei ole täysin ongelmaton valinta. Laiskan suorituksen on pidettävä kirjaa siitä, mitkä osat
ohjelmaa ovat suorittamatta, ja se kasvattaa yleiskustannuksia. Kirjanpidosta seuraava hidastus on
kuitenkin vakioinen ja verrattain pieni. Suurempi ongelma on se, että laiskan suorituksen
tilavaativuutta on vaikea arvioida ja se saattaa kasvaa ylilineaarisesti. Haskelliin on siksi
lisätty sekä tietorakenteita, jotka eivät ole laiskoja, että keino pakottaa lausekkeen evaluaatio,
jolloin laiskuuden voi poistaa sellaisesta kohdasta ohjelmaa, jossa se on haitaksi.

\subsection{Puhtaus}

Laiskuuden välitön seuraus on se, että evaluointijärjestys määräytyy tarpeen mukaan, jolloin
vastaavasti sivuvaikutusten käsittelyä on vaikeaa toteuttaa mielekkäästi. Sivuvaikutuksilla
tarkoitetaan esimerkiksi siirrännän käsittelyä (engl. \emph{input/output}) tai yleisesti ottaen mitä
tahansa ulkoista tilanmuutosta~\fixme{parempiselitys!}.

Haskell-komitean ratkaisu oli tehdä Haskellista puhdas kieli, jolloin funktioilla ei ole lainkaan
sivuvaikutuksia. Tässä mielessä Haskellin funktiot ovat paitsi nimeltään niin myös merkitykseltään
vastaavanlaisia matemaattisten funktioiden kanssa -- molemmat palauttavat samalla syötteellä aina
saman arvon.

Puhtauden vaikutukset ovat kaikenkattavat. Koska sivuvaikutuksia ei sallittu, oli Haskellin
alkuaikoina siirräntä tuskallisen hankalaa. Pakon edessä kehitettiin monadinen siirräntä, jota
voidaan pitää yhtenä Haskellin merkittävimmistä panostuksista ohjelmointikielten kehitykselle.
Keskustelu siitä, onko puhtaan kielen ja monadisten sivuvaikutusten yhdistelmä paras lähestymistapa
ohjelmistojen kehitykselle, on yhä kesken, mutta Haskellin tarjoama ehdotus on ainakin mullistava ja
elegantti. Lisäksi se on synnyttänyt paljon tutkimusta monadeista ja tilan kapseloinnista.

\subsection{Tyyppiluokat}

Tyyppiluokkia pidetään nykyisin yhtenä Haskellin tunnusmerkillisimmistä ominaisuuksista. Alunperin
tyyppiluokat tuotiin osaksi kieltä, koska oli tarve ratkaista yhtäsuuruuden vertaamisen ja
numeeristen operaatioiden ylikuormitus. Haskell-komitean tavoite oli suunnitella kieli käyttäen
olemassaolevia ja perusteellisesti tunnettuja menetelmiä, mutta Haskellia edeltäneissä
funktionaalisissa kielissä, kuten Mirandassa tai Standard ML:ssä, ei ylikuormitusta oltu ratkaistu
yhtenäisellä tavalla. Lisäksi aiemmin käytetyissä menetelmissä oli heikkouksia, kuten esimerkiksi
Mirandan polymorfinen yhtäsuuruusvertailu~\fixme{laajenna?}, joka saattoi johtaa ajonaikaisiin
virhetilanteisiin.

Tyyppiluokat mahdollistavat nimensä mukaisesti tyyppien luokittelun sen perusteella, mitä
ylikuormitettuja operaatioita ne tukevat. Esimerkiksi Haskellissa luokkaan \code{Eq} kuuluvalle
tyypille on toteutettu yhtäsuuruusvertailu. Tällöin käännösvaiheessa on mahdollista tarkistaa, että
\code{==}-operaattoria käytetään vain sellaisten tyyppien kesken, jotka kuuluvat
\code{Eq}-luokkaan. Vaikka tyyppiluokat olivat uusi keksintö eikä niiden toimivuutta oltu
todistettu aiemmin, Haskell-komitea päätyi omaksumaan ne osaksi kieltä, sillä niiden avulla kaikkien
tyyppien ylikuormitus oli ratkaistavissa yhtenäisellä, järjestelmällisellä ja modulaarisella
tavalla.

Jälkikäteen ajateltuna tyyppiluokkien ottaminen osaksi Haskellia oli onnekas valinta,
jolla on ollut kauaskantoisia vaikutuksia, sillä tyyppiluokat ovat monikäyttöinen työkalu ja niiden
avulla voi tehdä paljon muutakin kuin toteuttaa ylikuormituksen. Yksi merkittävä edistysaskel
Haskellin ja tyyppiluokkien kehitykselle oli ehdotus tyyppimuodostajan parametroimisesta
tyyppimuuttujan sijaan. Tämä mahdollisti korkeamman asteen polymorfismin (engl. \emph{higher-kinded
polymorphism}), jonka välitön sovellus oli monadien toteuttaminen.

\subsection{Syntaksi}

Koodiesimerkkejä käytetään ongelmien ja ratkaisujen havainnollistamiseen. Esimerkit seuraavat
syntaksiltaan Haskellia silloinkin, kun ne ovat pseudokoodia, joka ei käänny Haskell-ohjelmaksi.
Listauksessa~\ref{lst:esittely} esitellään käytetty syntaksi, jossa on kaksi osaa: funktion tyypin
määrittely ja varsinainen funktion määrittely. Tyyppimäärittely alkaa funktion nimellä, jonka
jälkeen tulee kaksi kaksoispistettä, jota seuraa mahdolliset parametrit ja paluuarvo eroteltuna
nuolella (\code{->}). Funktion määrittely alkaa myös funktion nimellä, jota seuraa mahdolliset
parametrit (tässä esimerkissä \code{x} ja \code{y}), joiden jälkeen tulee yhtäsuuruusmerkki ja
funktion vartalo.

\begin{lstlisting}[float,label={lst:esittely},caption={Syntaksin esittely}]
summa :: Int -> Int -> Int
summa x y = x + y
\end{lstlisting}


\section{Siirrännän vaikeus}

% Ollaanko me määritelty siirräntä missään vaiheessa? Tulostus, syötteen lukeminen, FFI,
% tilamanipulaatiot...

% Purkaa auki teknisemmälle yleisölle samalla käsitteitä määritellen tutkimuskysymyksen, ratkaisuille
%  ympäristöstä esiintulevat vaatimukset ja keskeiset käsitteet näiden asioiden esittelemiseksi.
% Antaa riittävästi termistöä ja kysymyksenasetteluja, jotta myöhempänä teksissä on mahdollisuus
%  analyysiin ja evaluointiin.

Haskellin kehityksen alkutaipaleella pohdittiin siirrännän toteuttamista ja siihen liittyviä
ongelmia. Valmista hyvänä pidettyä ratkaisua ei ollut olemassa, sillä olemassaolevien puhtaiden
funktionaalisten kielten siirräntää pidettiin epätyydyttävänä tai kielessä oli sallittu
sivuvaikutukset.

\subsection{Puhtaus}

Puhtaasta laskennasta on monia hyötyjä. \fixme{Parempi esimerkki!} Esimerkiksi rinnakkaista
ohjelmointia pidetään perinteisesti vaikeana, ja yksi merkittävä syy ohjelmointivirheille on se,
että suorituksen eri haarat lukevat tai muuttavat jaettua tilaa virheellisesti. Puhdas rinnakkainen
laskenta sen sijaan on sivuvaikutuksetonta, joten se on immuuni samoille ongelmille.

% https://en.wikipedia.org/wiki/Dijkstra_Prize

Sivuvaikutusten puute tarkoittaa myös sitä, että Haskell on viitteellisesti läpinäkyvä (engl.
\emph{referentially transparent}). Toisin sanoen minkä tahansa Haskellin lausekkeen voi korvata
kyseisen lausekkeen arvolla ilman, että ohjelman merkitys muuttuu. Käytännössä viitteellinen
läpinäkyvyys mahdollistaa optimoinnin, jossa kääntäjä pelkistää kaikki toistuvat viitteet yhdeksi.
Esimerkiksi listauksessa~\ref{lst:kuutio} muuttujan \code{x} arvo pitää selvitää vain kerran, jonka
jälkeen saadulla \code{x}:n arvolla korvataan jokainen \code{x}:n ilmentymä ja kertolaskut voidaan
laskea.

\begin{lstlisting}[float,label={lst:kuutio},caption={Puhdasta laskentaa}]
kuutio x = x * x * x
\end{lstlisting}

Esimerkin yksinkertaisuus saattaa hämätä, joten on syytä muistaa, että \code{x} voi olla
laskennallisesti mielivaltaisen haastava funktio, joten optimointi voi olla merkittävä. Lisäksi
ilman puhtautta \code{x}:n arvo saattaisi olla riippuvainen esimerkiksi ulkoisesta syötteestä,
jolloin optimointia ei voisi tehdä yhtä huolettomasti. Toisaalta aina puhtaudesta johtuva
optimointi ei johda toivottuun lopputulokseen.

\begin{lstlisting}[float,label={lst:samat},caption={Kaksi samaa funktiota}]
lueKaksiRivia = { readLine; readLine }
\end{lstlisting}

Esimerkissä~\ref{lst:samat} käytetään kahdesti samaa funktiota, jonka tarkoitus on lukea käyttäjän
antama syöte. Koska kääntäjä luottaa puhtauteen ja optimoi identtiset funktiot yhdeksi
evaluaatioksi, tapahtuu varsinainen luku vain kerran, sillä sen jälkeen molempien funktioiden
ilmentymä voidaan korvata kerran tehdyn evaluaation palauttamalla arvolla. Siirrännän käsittelyssä
puhtaus ja sen seuraukset eivät aina ole toivottavia.

\subsection{Laiskuus}

Laiska suoritus sopii hyvin yhteen puhtaan funktionaalisen kielen kanssa, mutta sekin tekee
siirrännän käsittelyn vaikeaksi. Listauksessa~\ref{lst:tulostus} on esimerkkiohjelma, jossa
määritellään funktio \code{sanoHaskell}, jonka tarkoitus on tulostaa merkkijono `Haskell'
oletustulostusvirtaan.

\begin{lstlisting}[float,label={lst:tulostus},caption={Tulostava esimerkkiohjelma}]
sanoHaskell = print "Haskell"
\end{lstlisting}

Imperatiiviseen paradigmaan tottunut saattaisi olettaa, että ohjelma tulostaa `Haskell' ja lopettaa.
Laiska suoritus kuitenkin johtaa siihen, ettei mitään tulostu. Funktiota \code{print} ei koskaan
evaluoida, sillä sivuvaikutuksista ei välitetä eikä funktio palauta mitään sellaista arvoa, joka on
tarpeen ohjelman suorittamiseksi. Toisin sanoen ohjelman tulostus optimoidaan pois, vaikka se on
ohjelman ainoa varsinainen tarkoitus.

Laiskuuteen ja siirräntään liittyy myös toinen ongelma, joka on hieman hienovaraisempi.
Listauksen~\ref{lst:jarjestys} esimerkissä määritellään funktio \code{sanoHeiMaailma}, jonka on
tarkoitus suorittaa kaksi merkkijonon tulostusta. Imperatiivisissa ohjelmissa suoritus on
tavanomaisesti ahnetta ja ohjelman suoritus seuraa kirjoitetun koodin rakennetta, mutta sama sääntö
ei päde laiskaan evaluointiin. Tästä seuraa se, ettei ole olemassa takeita siitä, missä
järjestyksessä esimerkkiohjelman tulostukset suoritetaan.

\begin{lstlisting}[float,label={lst:jarjestys},caption={Kahden tulostuksen pseudokoodi}]
sanoHeiMaailma = { print "Hei"; print " maailma" }
\end{lstlisting}

Toisin sanoen siinäkin tapauksessa, että tulostukset suoritettaisiin laiskuudesta huolimatta,
saattaa merkkijono `maailma' tulostua ennen merkkijonoa `Hei'. Tämä on luonnollisesti merkittävä
ongelma, sillä yleisessä käyttötapauksessa siirrännän käsittelyn tulee tapahtua määrätyssä
järjestyksessä, jotta ohjelma toimii tarkoituksenmukaisesti.

\subsection{Kohti imperatiivisuutta}

Listauksessa~\ref{lst:ratkaisu} on ohjelma, jonka käyttötarkoitus on sama kuin aiemmassa
listauksessa~\ref{lst:samat} eli ohjelman tulisi lukea syöte kahdesti, mutta toteutusta on
laajennettu siten, että puhtauden ja laiskuuden aiheuttamat ongelmat on pyritty ratkaisemaan.
Lisäksi tällä kertaa käytettyjen funktioiden tyyppimäärittelyt ovat kirjoitettu näkyviin.
Ratkaisussa on käytetty tekaistuja parametreja, joiden avulla suoritusjärjestys pakotetaan
halutunlaiseksi. Tekaistujen parametrien tyyppi ei ole tärkeä, ja listauksessa käytetty \code{Int}
on valittu vain yhtenä esimerkkinä kaikista mahdollisuuksista.

\begin{lstlisting}[float,label={lst:ratkaisu},caption={Suoritusjärjestys riippuvuuksien avulla}]
lueRivi       :: Int -> ( String,  Int)
lueKaksiRivia :: Int -> ([String], Int)

lueKaksiRivia p0 = ([s1, s2], p2) where
  (s1, p1) = lueRivi p0
  (s2, p2) = lueRivi p1
\end{lstlisting}

Funktio \code{lueKaksiRivia} palauttaa arvot \code{s1} ja \code{s2}, jotka edustavat niitä
merkkijonosyötteitä, joiden lukeminen on ohjelman varsinainen tavoite. Lisäksi ohjelma palauttaa
tekaistun arvon \code{p2}. Ohjelman toiminta on helpoin päätellä seuraamalla ohjelman suoritusta
kääteisessä järjestyksessä. Jotta \code{p2}:n arvo saadaan selville, on välttämätöntä suorittaa
funktio \code{lueRivi p1}. Jotta se voidaan suorittaa, täytyy saada selville arvo \code{p1}, joka
vuorostaan vaatii funktion \code{lueRivi p0} suorituksen ensin. Tällöin tekaistuilla parametreilla
on saavutettu se, että funktioilla \code{lueRivi} on muuttujien arvoon liittyvä riippuvuus, jolloin
laiska suoritus ei voi poimia suoritusjärjestystä mielivaltaisesti.

Samalla vältetään puhtaudesta juontuvat ongelmat. Funktioita \code{lueRivi p0} ja \code{lueRivi p1}
ei voi pelkistää yhdeksi evaluaatioksi, sillä ne saavat eri parametrit.

Funktion \code{lueKaksiRivia} saama parametri \code{p0} ei ole välttämätön tämän esimerkin kannalta,
mutta on tärkeä laajemmassa kontekstissa, sillä se mahdollistaa funktioiden koostamisen (engl.
\emph{function composition}). Jos funktiolle \code{lueRivi} ei voisi antaa mitään parametria, ei
puhtauden ja laiskuuden ongelmia olisi voitu ratkaista tekaistuilla parametreilla. Vastaavasti ilman
parametria \code{p0} olisi funktiolla \code{lueKaksiRivia} sama ongelma laajemman ohjelman
kontekstissa. Tästä syystä ei ole lainkaan sattumaa, että käytettyjen funktioiden tyyppimääritelmät
ovat hyvin samankaltaiset, sillä molempien funktioiden on tarkoitus toteuttaa siirräntää puhtaassa
ja laiskassa kielessä.

Vaikka tämän esimerkin ohjelman voi nähdä toimivan tarkoituksenmukaisella tavalla, on se samalla
muuttunut huomattavasti monimutkaisemmaksi. Ohjelma on vaikeaselkoinen, koska eri parametrien
tarkoitus ei ole ilmeinen, ja toisaalta tekaistujen parametrien käyttö ohjelman suorituksen
ohjaamiseen on semanttisesti ongelmallista.

\subsection{Tavoitteet}

Siirrännä toteuttaminen puhtaassa ja laiskassa kielessä ei ole itsestäänselvä asia, jonka vuoksi
jotkut funktionaaliset ohjelmointikielet ovat luopuneet puhtauden vaatimuksesta ja hyväksyneet
sivuvaikutukset osaksi siirrännän toteutusta. Koska Haskellin suunnittelun kulmakivi alusta alkaen
on ollut puhtaus ja laiskuus, on ratkaisun siirrännän toteuttamiseksi oltava yhteensopiva niiden
kanssa.

Ohjelmat yleensä kokonaisuuksia, jotka syntyvät pienemmistä osatekijöistä. Funktionaalisten kielien
luonnollinen vahvuus on perinteisesti ollut se, että funktioita on helppo koostaa osaksi korkeamman
asteen funktioita (engl. \emph{function composition}). Haskellin siirrännän ratkaisun olisi tulisi
säilyttää tämä ominaisuus, jotta kielen käytettävyys tai ilmaisuvoima ei heikkene, jos ohjelman
tarvitsee tehdä siirräntää.

Lisäksi ratkaisun tulisi olla soveltuva ohjelmointikieleen yleisesti. Suotavia ominaisuuksia ovat
mm. ratkaisun yleishyödyllisyys ja laajennettavuus, tehokkuus ja toteutuksen helppous. Toisin sanoen
olisi kätevää, jos siirrännän haasteet olisivat ratkaistavissa siten, että samaa mallia voisi
soveltaa muihin Haskellin kipukohtiin. Ja niin kuin kaikkien ohjelmointiin liittyvien ongelmien
kanssa ei ratkaisu voi olla laskennallisesti liian vaativa tai sen käyttökelpoisuus heikkenee.


\section{Kategoriateoria}

\subsection{Historia}

Alunperin kategoriateoria ja monadit tulivat osaksi tietojenkäsittelytiedettä vuonna 1989 Eugenio
Moggin julkaisun "Computational Lambda-calculus and Monads"~\cite{clcam89,nocam91} myötä. Moggi
tutki ohjelmointikieliä ja keinoja, joilla tietokoneohjelmista voidaan vetää loogisia
johtopäätöksiä, kuten esimerkiksi osoittaa kahden ohjelman yhdenmukaisuus.

Lambdakalkyyli oli aiemmin tarjonnut matemaattisen teoreettisen pohjan ohjelmien yhdenmukaisuuden
vertailuun. Lambdakalkyylin ei kuitenkaan ollut ongelmaton valinta, sillä se vaati ohjelman tai
proseduurin merkityksen pelkistämisen täydelliseksi funktioksi (engl. \emph{total function}).
Tällöin menetetään mahdollisuus tarkastella muun muassa pysähtyvyyttä, epädeterministisyyttä ja
sivuvaikutuksia, jotka ovat yleisiä oikeissa ohjelmissa.

% (1) https://en.wikipedia.org/wiki/Denotational_semantics
%
% (2) "Moggi seeks to capture the intuitive notion of a computation in the most general setting
% possible." -- Kategoriateoreettinen lähestymistapa tarjoaa yhdenmukaisuudelle ja pysähtymiselle
% luonnollisen selityksen. -- "That existence and equivalence are so readily definable suggests that
% far from just being a way to hide I/O or statefulness, Monads and their attendant laws express the
% conditions satisfied by a computation strategy."

Moggin valinta oli käyttää kategoriateorian tarjoamaa semanttista kehystä laskennan mallintamiseen.
Erityisesti Moggin innovaatio oli hyödyntää monadeja, joka mahdollisti ohjelmointikielen
ominaisuuksien jakamisen erillisiin osiin niiden semantiikan perusteella. Tällöin esimerkiksi
siirräntä, poikkeukset tai muut toisistaan poikkeavat ominaisuudet saivat oman erillisen kontekstin,
jossa niitä voitiin tarkastella.

Philip Wadler havaitsi, että Moggin käyttämä strategia rakenteen luomiseen semantiikan avulla
soveltuisi myös funktionaalisten ohjelmien jäsentämiseen. Toisin sanoen siinä missä Moggi käytti
monadeja ohjelmien kuvaamiseen, päätti Wadler hyödyntää monadeja ohjelmien
ilmaisemiseen~\cite{cm90,teofp92}.

\subsection{Kategoria}

Kategoriateoria on abstrakti matemaattinen työkalu, joka mahdollistaa monien matemaattisten
käsitteiden formalisoinnin. Kategoriateoreettinen lähdestymistapa mahdollistaa erillaisten
matemaattisten rakenteiden (kuten esimerkiksi joukkojen, ryhmien tai vektoriavaruuksien) tarkastelun
rakenteen säilyttävällä tavalla, jolloin kategorian tutkiminen sallii yhteisten piirteiden
kuvaamisen ja todistamisen.

Kategoria muodostuu kahdesta tekijästä, jotka ovat merkityksellisiä Haskellin näkökulmasta: olioista
ja morfismeista. Morfismeja (engl. \emph{morphisms}) kutsutaan myös nuoliksi (engl. \emph{arrow}),
mutta nuolella on Haskellissa eri merkitys, joten jatkossa pitäydytään nimityksessä morfismi.
Merkintä $f : A \rightarrow B$ tarkoittaa morfismia $f$ lähdeoliolta $A$ kohdeoliolle $B$ jossain
oletetussa kategoriassa.

Yhdiste (engl. \emph{composition}) on binäärioperaatio morfismeille siten, että jos samassa
kategoriassa on olemassa morfismit $f : A \arr B$ ja $g : B \arr C$, on oltava myös niiden
yhdistemorfismi $g \circ f : A \arr C$. Lisäksi morfismit noudattavat kahta sääntöä. Ensinnäkin
morfismien yhdisteen tulee olla assosiatiivinen. Toisin sanoen:

$$f \circ (g \circ h) = (f \circ g) \circ h$$

Toiseksi missä tahansa kategoriassa $\mathcal{C}$ on olemassa jokaiselle oliolle $A$
identiteettimorfismi $1_A : A \arr A$. Tarkemmin sanottuna jokaiselle morfismille $f : A \arr B$
pätee:

$$ 1_A \circ f = f = f \circ 1_B $$

%% https://wiki.haskell.org/Hask

Miten sitten kategoriat liittyvät Haskelliin? Haskellin yhteydessä puhutaan usein kategoriasta
nimeltään \code{Hask}, joka tarjoaa teoreettisen kehyksen ohjelmointikielen itsensä tarkasteluun.
\code{Hask}-kategorian kontekstissa Haskellin tyypit vastaavat kategoriateorian olioita ja funktiot
vastaavat morfismeja. Lisäksi funktiokompositio \verb|(.)| toimii Haskellissa yhdistemorfismina,
sillä se on assosiatiivinen, ja funktio \code{id} toteuttaa identiteettimorfismin vaatimuksen.

Päällisin puolin näyttää siltä, että Haskellin ominaisuudet luovat suoraan kategorian siten kuin
kategoriateoria sen määrittelee. Tämä ei kuitenkaan pidä paikkaansa, sillä on olemassa rajatapauksia
erityisesti määrittelemättömien ja tyhjien arvojen kanssa, joissa Haskell ei käyttäydy
kategoriateorian sääntöjen mukaisesti. Sen sijaan ei ole väärin ajatella, että Haskell on omaksunut
vaikutteita kategoriateoriasta ja sen seurauksena Haskellin monadit ovat analogisia kategoriateorien
monadien kanssa.

% The category must satisfy an identity axiom and an associative axiom
% which is analogous to the monoid axioms.

% \subsection{Monoidi}
% \fixme{Onko tarpeen puhua monoideista?}

% \subsection{Funktori}
% \fixme{Onko tarpeen puhua funktoreista?}

\subsection{Monadi}

\begin{lstlisting}[float,float,label={lst:monad},caption={Monad-tyyppiluokka}]
class Applicative m => Monad m where
  (>>=)  :: forall a b. m a -> (a -> m b) -> m b
  (>>)   :: forall a b. m a -> m b -> m b
  return :: a -> m a
\end{lstlisting}

Monadi on yksi kategoriateorian yleisimmin hyödynnetyistä rakenteista, joka on osoittautunut
monikäyttöiseksi työkaluksi myös ohjelmointikieliä tarkasteltaessa. Erityisesti funktionaalisten
kielian tapauksessa monadit sallivat laskennan kuvaamisen riittävän abstraktilla tavalla, jotta ne
ovat päätyneet ratkaisemaan lukuisia käyttötapauksia. Pelkästään Haskellin standardikirjasto tarjoaa
monadeihin tukeutuvia työkaluja paitsi siirrännän niin myös tilan, virheenkäsittelyn ja
epädeterministisen laskennan tarpeisiin.

Monadit ovat toteutettu Haskellissa tyyppiluokkana. Listauksessa~\ref{lst:monad} on lainaus
Haskell-kääntäjän GHC (\emph{Glasgow Haskell Compiler}) lähdekoodista, josta on nähtävissä
\code{Monad}-luokka ja tyyppimääritelmät sen kolmelle metodille (eli luokan funktiolle). Yksittäiset
tyypit, joille periytetään monadin ominaisuudet, määrittelevät tarkoitukseensa sopivan toteutuksen
vaadituille metodeille.

Jotta luotu tyyppi käyttäytyy oikean monadin tavoin, täytyy metodien toteutuksen seurata kolmea
sääntöä, joita kutsutaan myös monadilaeiksi (engl. \emph{monad laws}). Säännöt pitävät huolta siitä,
että monadien yhdisteet toimivat assosiatiivisesti ja että metodit säilyttävät toimintojen samuuden.
Haskellin ilmaisuvoima ei riitä siihen, että kääntäjä pystyisi todistamaan jonkun tyypin täyttävän
monadilait, joten se tehtävä jää ohjelmoijan vastuulle, jos hän tahtoo luoda uuden monadin.

% Tähän voi ehkä palata sitten kun metodit on käsitelty
%\begin{lstlisting}[float,float,label={lst:laws},caption={Monadilait}]
%return a >>= f                  =  f a
%m        >>= return             =  m
%m        >>= (\x -> f x >>= h)  =  (m >>= f) >>= h
%\end{lstlisting}

\subsection{Monadin toteutus}

Mitä monadiin kuuluvat funktiot sitten tekevät? Ensimmäinen niistä on \code{>>=}, joka luetaan
\emph{bind} tai suomeksi \emph{sidos}. Kuten nimi viittaa sidoksen avulla voi yhdistää kaksi monadin
toiminto. Tyypillisesti sidosta käytetään sisämerkintänä argumenttiensa välissä. Esimerkiksi \code{a
>>= f} tarkoittaa, että toimisto \code{a} ja funktio \code{f} ketjutetaan yhteen siten, että
evaluaation aikaan toiminto \code{a} suoritetaan, sen paluuarvo sovelletaan funktioon \code{f},
josta saadaan koko lauseen paluuarvo.

Toinen monadin funktio \code{>>} luetaan \emph{then}, jonka voi kääntää suomeksi \emph{sitten}. Se
toimii muutoin samankaltaisesti sidoksen kanssa, mutta se ei huomioi ensimmäisen toiminnon
paluuarvoa. Toisin sanoen sitä voi käyttää yhdistämään toimintoja, joiden paluuarvoilla ei ole
merkitystä. Jos tarkkoja ollaan \code{>>} ei ole teoriassa pakollinen toimivan monadin
toteuttamiseksi, mutta käytännön ohjelmoinnin ja koodin selkeyden näkökulmasta se on hyödyllinen.

% return on nimeltään unit kategoriateoriassa

Useissa imperatiivisissä ohjelmointikielissä tunnetaan avainsana \code{return}, jonka tarkoitus on
keskeyttää aliohjelman suoritus ja palauttaa jokin arvo. Haskellissa \code{return} on funktio, joka
nostaa argumenttinsa monadin kontekstiin. Toisin sanoen \code{return a} evaluoituu monadiseksi
tyypiksi, joka pitää sisällään arvon \code{a}. Funktion \code{return} nimi on valitettava sillä se
aiheuttaa paljon hämmennystä uusien Haskellin harrastajien keskuudessa.

\subsection{Toimiva ohjelma}

Listauksessa~\ref{lst:then} on päivitetty versio luvun~\ref{subsec:laiskuus} esimerkistä. Ohjelmaa
on muutettu siten, että tulostustoiminnot ovat yhdistetty \emph{then}-funktiolla, jonka lisäksi
tyyppimääritelmä on kirjoitettu näkyviin sen korostamiseksi, että toiminnot ovat suoritettava
IO-monadin kontekstissa. Tällä kertaa ohjelma on täysin toimiva ja se tulostaa merkkijonot
toivotulla tavalla.

\begin{lstlisting}[float,label={lst:then},caption={Toimiva tulostus}]
sanoHeiMaailma :: IO ()
sanoHeiMaailma = putStr "Hei" >> putStr " maailma"
\end{lstlisting}

Päällepäin katsottuna ei kuitenkaan ole ilmeistä, kuinka ohjelma eroaa
listauksesta~\ref{lst:jarjestys}? Näemme että ohjelma hyödyntää \code{then}-funktiota, mutta mikä
mekanismi pitää huolta, että tulostukset ylipäätään tapahtuvat. Ja onko ohjelma yhä puhdas ja
viitteellisesti läpinäkyvä?

% onko composition takuu järjestyksestä selitetty? no ei oo
% miten main :: IO () toimii? no koska maailma

%  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %

%  Monads can be thought of as composable computation descriptions.
%  The essence of monad is thus separation of composition timeline
%    from the composed computation's execution timeline,
%    as well as the ability of computation to implicitly carry extra data,
%    as pertaining to the computation itself, in addition to its one output,
%    that it will produce when run.

%  Haskellissa oli kätevästi tyyppiluokat valmiina, ja niiden avulla Monad:n luonti helppo

%  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %

\section{Siirrännän toteutus}

% Tähän voisi lisätä monadisen I/O:n hyvät puolet:
%  composable
%  easily extensible
%  efficient
%  ^ archieved by transformations
%  extendable to interleaved I/O
%  extendable to in-place manipulation
%  only Hindley-Milner required

% We need a way to reconcile being with doing: an expression in a functional
% language denotes a value, while an I/O command should perform an action.

\subsection{IO-monadi}

Siirräntää varten Haskelliin on lisätty \code{IO}-tyyppi, joka joka ilmaisee toimintoa. \code{IO} on
yhdistelmätyyppi (engl. \emph{algebraic data type}), joka ottaa parametrikseen toisen tyypin, joka
ilmaisee toiminnon palautteen tyypin. Esimerkiksi funktio tyyppiä \code{IO Int} voi suorittaa
siirräntää ja palauttaa sen jälkeen kokonaislukuarvon.

\code{IO}-tyypille on myös määritelty \emph{Monad}-tyyppiluokan ilmentymä, joka tarkoittaa sitä,
että \code{IO}-tyypille on määritelty monadiset operaatiot \emph{bind}, \emph{then} ja
\emph{return}. Koska siirrännän toimiminen vaatii monadin ominaisuudet ja ne ovat \emph{IO}:n
leimallinen piirre, on tyypillistä puhua \emph{IO-monadista} IO-tyypin sijaan.

Samoin kuin monet aiemmat funktionaaliset ohjelmointikielet, myös Haskell käyttää
Hindley--Milner-tyyppijärjestelmää. Haskellissa on myös alusta alkaen ollut tyyppiluokat osana
kielen ilmaisuvoimaa. Kun IO-monadi päätettiin lisättiin Haskelliin 90-luvun alussa, oli se
teknisessä mielessä verrattain helppo operaatio, sillä monadit olivat luonteva toteuttaa
tyyppiluokkien avulla ja IO-tyyppi soveltui Hindley--Milner-järjestelmään sellaisenaan.

\subsection{Toiminto ja suoritus}

Funktionaalisessa kielessä lauseke ilmaisee arvoa, kun taas siirräntä on luonteeltaan suorite, joka
tulisi toteuttaa. Osana siirrännän ratkaisua on Haskellissa erotettu olemassaoleminen ja tekeminen
toisistaan. Tätä jakoa edustaa IO-monadi, joka on toiminto (engl. \emph{action}) ja jonka suoritus
(engl. \emph{perform}) voi toteuttaa siirräntää ja palauttaa arvon. Jatkossa \emph{toiminto}
tarkoittaa aina jotain funktiota, joka on \code{IO}-tyyppiä.

Erottelemalla toiminnon suorittamisesta \code{IO}-tyyppiset funktiot kapseloivat siirrännän siten,
että ne ovat yhteensopivat Haskellin puhtaan funktionaalisen paradigman kanssa säilyttäen
viitteellisen läpinäkyvyyden. Toisin sanoen toiminnot ovat tavallisia funktiota, joita voidaan
välittää argumenttina, koostaa osaksi korkeamman asteen funktioita (engl. \emph{function
composition}) ja yleisesti ottaen käsitella kaikilla funktionaalisen kielen keinoilla.

%% Too soon?
%Toiminnon ja suorituksen erottelu johtaa luonnollisesti kysymykseen siitä, mikä saa aikaan
%toimintojen suorittamisen? Haskellin ratkaisu on määritellä ohjelma toiminnoksi nimeltään
%\code{main}, joka on tyyppiä \code{IO ()}, ja jonka suoritus vastaa koko ohjelman suorittamista.
%Koska Haskell-ohjelma on funktionaalisesta semantiikasta johtuen mielivaltainen yhdistelmä
%matalamman tason funktioita ja toimintoja, johtaa \code{main}-toiminnon suoritus myös matalan tason
%toimintojen suorittamiseen silloin, kun \code{main}-toiminnon suoritus sitä vaatii.

\subsection{Toimintojen yhdistäminen} %% eli miten monadityökalut tekee IO:n

% FIXME Tässä olisi oleellista jotenkin kertoa se kuinka >>= / >> luo tietoriippuvuuden,
%       järjestää toiminnot ja estää kääntäjää optimoimasta niitä pois. Hyvä esimerkki
%       ja ajatus tarpeen.

\fixme{Voiskohan tää alkaa jotenkin näin} Siirräntä on vaikeaa puhtauden ja laiskuuden takia, sillä
niiden ei ole takuuta siitä, että siirräntää suoritetaan tai että suoritus tapahtuu oikeassa
järjestyksessä. Monadit ratkaisevat järjestämiseen liittyvän ongelman luomalla viitekehyksen
\fixme{mikä ihmeen viitekehys, selitä}, jossa toiminnot nimenomaisesti ketjutetaan toisiinsa.

Listauksessa~\ref{lst:ioprog} on kolme osaa. Kahdella ensimmäisellä rivillä on esimerkkiohjelma,
joka lukee merkin vakiosyötteestä ja tulostaa sen vakiotulosteeseen. Ohjelma käyttää toimintoja
\code{getChar}, \code{putChar} ja \code{>>=}, joiden tyypit ovat kirjoitettu auki. Esimerkiksi
\code{getChar :: IO Char} tarkoittaa toimintoa, joka palauttaa \code{Char}-tyyppisen arvon.

Listauksessa käydään myös esimerkkiohjelman evaluaatio vaihe vaiheelta läpi ohjelman käyttämien
tyyppien avulla. Evaluaation ensimmäisellä rivillä ohjelma on muutoin muuttumaton, mutta
\code{(>>=)} funktio on siirretty sisämerkinnästä parametriensa eteen, jotta esimerkkiä olisi
helpompi seurata myöhemmin.

Toisella rivillä \code{(>>=)} on korvattu tyyppimääritelmällään. Tässä vaiheessa IO-tyyppi on vielä
polymorfisesssa muodossa, sillä lopullista tyyppiä ei vielä tiedetä. Toisin sanoen merkinnässä
käytetään yhä \code{a} ja \code{b} -tyyppiparametreja.

Kolmannella rivillä \code{getChar} on korvattu tyypillään ja samalla huomaamme että sen tyyppi sopii
sidosfunktion ensimmäisen parametrin tyyppiin, jos tyyppiparametri \code{a} saa arvon \code{Char}.
Tarkennamme tyyppimääritelmiä korvaamalla \code{IO a} -merkinnän tyypillä \code{IO Char}.

Neljännellä rivillä sievennämme lauseketta soveltamalla \code{getChar}-funktion ja poistamme sen
merkinnöistä. \fixme{Tässä vaiheessa Haskell-ohjelman suoritusta tapahtuu toiminnan suoritus.}

Viidennellä rivillä \code{putChar}-funktio korvataan tyypillään ja voimme jälleen tehdä
tyyppipäättelyn samalla tavalla kuin kolmannella rivillä. Huomaamme että tyyppiparametrin \code{b}
tyypiksi sopii \code{()} ja se mahdollistaa \code{putChar}-funktion soveltamisen. Tässä vaiheessa
alkuperäisestä sidosfunktiosta on jäljellä enää toinen parametri ja paluuarvo. Kuudennellä rivillä
funktio \code{putChar} on sovellettu sidosfunktioon ja jäljelle jää enää paluuarvon tyyppi \code{IO
()}.

Siirrännän lisäksi tämä esimerkki kattaa monta yleistä funktionaalisen kielen ominaisuutta, jotka
ovat syytä mainita selkeyden vuoksi. Ohjelman sieventäminen tyyppien avulla on vastaavanlainen
operaatio kuin kääntäjän tekemä tyyppipäättely Haskell-ohjelmaa käännettäessä. Esimerkin
sieventyminen tyypiksi \code{IO ()} ei ole sattuma, sillä se on vaatimus kaikille
Haskell-ohjelmille, sillä kaikkien omavaraisten Haskell-ohjelmien suoritus alkaa
\code{main}-funktiosta, jonka tyyppi on \code{IO ()}.

Toinen merkittävä funktionaaliseen kieleen liittyvä havainto on se kuinka ohjelmaa suoritetaan.
Toisin kuin imperatiivisessa kielissä, ei suoritus koostu toisistaan riippumattomien lauseiden
ajamisesta. Sen sijaan ohjelma itsessään on kokonainen funktio, joka koostuu pienemmistä
funktioista. Haskell-ohjelmaa suoritetaan funktioita soveltamalla ja sieventämällä.


% käy läpi esimerkki, funktion sovellus, sievennys...

% funktionaalisen kielen juttuja:
%  [check] hups, vahingossa tyyppitarkistus
%  ei imperatiivista suorittamista vaan soveltamista, sieventämistä...

% i/o juttuja:
%  >>= on eksplisiittinen
%  >>= ketjuttaa tapahtumat
%  kaikki sitoutuu lopulta pääohjelmaan main
%  siirräntä tehdään tarvittaessa ja järjestetysti

\subsection{TODO}


%  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %  %%  %

% Listauksessa~\ref{lst:bind} on ohjelma, joka lukee merkin vakiosyötteestä ja tulostaa sen
% vakiotulosteeseen. Ohjelma käyttää toimintoja \code{getChar} ja
% \code{putChar}, joista ensimmäinen on tyypiltään \code{IO Char}, sillä sen suorituksen
% jälkeinen paluuarvo on merkki, ja jäljempi on tyypiltään \code{Char -> IO ()}, sillä se ottaa
% argumentikseen tulostettavan merkin eikä ei palauta mitään arvoa. Haskellissa tyhjiä sulkeita
% käytetään olemattoman arvon merkitsemiseen, ja niiden käyttö on välttämätöntä tässä tapauksessa,
% sillä \code{IO} vaatii tyyppiparametrin.

\begin{lstlisting}[float,label={lst:ioprog},caption={IO-ohjelma ja sen evaluaatio}]
main :: IO ()
main = getChar >>= putChar

getChar :: IO Char
putChar :: Char -> IO ()
(>>=)   :: IO a -> (a -> IO b) -> IO b

1. (>>=) getChar putChar
2. (IO a -> (a -> IO b) -> IO b) getChar putChar
3. (IO Char -> (Char -> IO b) -> IO b) (IO Char) putChar
4. ((Char -> IO b) -> IO b) putChar
5. ((Char -> IO ()) -> IO ()) (Char -> IO ())
6. IO ()
\end{lstlisting}

% bind ei ole language construct vaan ihan vaan funktio
% huomionarvoista että get >>= put on tosi simppeli ohjelmoinjan näkökulmasta

Esimerkin toiminnot ovat yhdistetty \verb|(>>=)| funktiolla, joka luetaan \emph{bind} eli suomeksi
sidos. Bindia käytetään tavallisesti sisämerkintänä (engl. \emph{infix notation}) eli tässä esimerkissä
bind saa argumenteikseen toiminnot \code{getChar} ja \code{putChar}. Bindin toteutus ei ole
esimerkissä näkyvillä, mutta tyyppimääritelmä paljastaa oleellisen osan bindin toiminnasta.

Bind on polymorfinen funktio, jota merkitään tyyppiparametrin pienillä kirjaimilla \code{a} ja
\code{b}, jotka voi korvata millä tahansa oikealla tyypillä. Tämän esimerkin tapauksessa
Haskell-kääntäjä päättelee, että \code{a} on \code{Char} ja \code{b} on \code{()}, sillä ne
vastaavat käytettyjen toimintojen tyyppejä. Lisäksi bindin paluuarvo tyyppipäättelyn jälkeen on
\code{IO ()}, joka vastaa \code{main}-toiminnon paluuarvoa, joten ohjelma läpäisee
tyyppitarkastuksen.

Esimerkkiohjelman voi lukea seuraavalla tavalla: \code{getChar} palauttaa toiminnon \code{IO Char},
jonka \code{Char}-tyyppinen arvo tarvitaan parametriksi, jotta voidaan toteuttaa \code{putChar}:n
palauttama toiminto, joka vastaavasti tuottaa lopullisen tarvittavan arvon \code{IO ()}. Toisin
sanoen bind luo tietoriippuvuuden (engl. \emph{data dependency}) käytettyjen toimintojen välille,
jolloin laiska evaluaatio ei voi enää suorittaa siirräntätoimintoja mielivaltaisessa järjestyksessä.

% TODO Täällä merkataan operaattoreita tekstissä sulkujen sisällä (>>), mutta koodissa ilman. Pitää
%      ehkä mainita kirjoitusasusta jotain

%Bind eli \verb|(>>=)| ei ole sattumalta osa Haskellin standardikirjastoa vaan yhdessä
%\code{return}-funktion kanssa ne täyttävät teoreettiset vaatimukset Haskellin Monad-tyyppiluokan
%määritelmälle. Lisäksi määritelmään kuuluu myös \emph{then}, joka kirjoitetaan \verb|(>>)|.

%Monissa imperatiivisissa ohjelmointikielissa \code{return} on kielen avainsana, jonka tarkoitus on
%keskeyttää aliohjelman suoritus. Haskellissa \code{return} on funktio, joka nostaa parametrinsa
%monadiseen kontekstiin. \fixme{Selitäppä tuo seuraavaksi! Ehkä jokin esimerkki.}

%Then, jonka voi kääntää suomeksi \emph{sitten}, on bindin erikoistapaus, jolla yhdistetään kaksi
%toimintoa, joista ensimmäinen ei palauta arvoa, jota toinen toiminto käyttäisi. Then ei ole
%pakollinen monadin toteuttamiseksi, mutta se on hyödyllinen käytännön ohjelmoinnin näkökulmasta.

% Listauksessa~\ref{lst:then} on korjattu versio luvun~\ref{subsec:laiskuus} esimerkistä. Ohjelmaa on
% muutettu niin, että tulostustoiminnot ovat yhdistetty then-funktiolla, joka takaa sen, että
% tulostukset tapahtuvat aiotussa järjestyksessä. Lisäksi tyyppimääritelmä on kirjoitettu näkyviin sen
% korostamiseksi, että kyseinen toiminto tulee suorittaa IO-monadin kontekstissa.

%\begin{lstlisting}[float,label={lst:then},caption={Fixme}]
%sanoHeiMaailma :: IO ()
%sanoHeiMaailma = putStr "Hei" >> putStr " maailma"
%\end{lstlisting}

\subsection{Imperatiivinen tyyli}
% Viitteeksi ehkä jotain Wadleria (kuten Comprehending Monads)

Imperatiivinen ohjelmointi soveltuu hyvin siirräntään, sillä imperatiivisen koodin rakenne ja
ohjelman semantiikka vastaavat toisiaan. Haskelliin on siksi lisätty \emph{do}-merkintätapa (engl.
\emph{do-notation}), joka mahdollistaa Haskell-ohjelmakoodin kirjoittamisen imperatiiviseen tyyliin
funktionaalisen tyylin sijaan. Do-merkintätapa on syntaktista sokeria, joten se lisää eikä vähennä
Haskellin kielellistä ilmaisuvoimaa.

Do-merkintätapa lisää Haskelliin avainsanat \code{do} ja \verb|<-|. Avainsana \code{do} aloittaa
koodilohkon, joka rajataan ympäröivästä ohjelmasta sisentämällä, ja jonka kontekstissa kääntäjä
muuntaa (engl. \emph{desugar}) rivinvaihdot monadisiksi yhdistefunktioiksi. Avainsana \verb|<-|
luetaan bind, sillä sen avulla voidaan sitoa toiminnon paluuarvo nimeen, jota käytetään myöhemmin.
Toisin sanoen kääntäjä muuntaa sen \verb|(>>=)|-funktioksi.

\begin{lstlisting}[float,label={lst:desugared},caption={Funktionaalinen tyyli}]
main :: IO ()
main = putStrLn "Mikä on nimesi?"
       >>
       getLine
       >>=
       \nimi -> putStrLn ("Hei " ++ nimi ++ "!")
\end{lstlisting}

\begin{lstlisting}[float,label={lst:donotation},caption={Imperatiivinen tyyli ja do-merkintätapa}]
main :: IO ()
main = do
  putStrLn "Mikä on nimesi?"
  nimi <- getLine
  putStrLn ("Hei " ++ nimi ++ "!")
\end{lstlisting}

Listauksessa~\ref{lst:desugared} on esimerkkiohjelma, joka kysyy käyttäjän nimeä, lukee syötteen ja
tulostaa tervehdyksen. Koska ensimmäisenä tehtävä tulostus ei palauta merkityksellistä arvoa,
käytetään seuraavaksi funktiota then. Sen sijaan \code{getLine} on tyyppiä \code{IO String}, joten
sen jälkeen käytetään funktiota bind, jotta palautettu merkkijono voidaan välittää eteenpäin.
Viimeisellä rivillä merkkijono sidotaan nimeen \code{nimi} lambda-abstraktion avulla, jotta
viimeisessä tulostuksessa siihen voidaan viitata.

Listauksessa~\ref{lst:donotation} on sama ohjelma, joka on kirjoitettu do-merkintätapaa käyttäen.
Tällöin monadisia sidosfunktioita ei tarvitse kirjoittaa eksplisiittisesti näkyviin vaan kääntäjä
päättelee niiden tarpeen ja lisää ne ennen varsinaista kääntämistä. Toiminnon \code{getLine}
palauttama arvo sidotaan avainsanalla \verb|<-| nimeen samankaltaisella syntaksilla, millä missä
tahansa imperatiivisessa kielessä aliohjelman paluuarvo tallennettaisiin muuttujaan. Kuitenkaan
\code{nimi} ei ole muuttuja, sillä sen arvoa ei voi myöhemmin muuttaa.

Monadinen siirräntä ja do-merkintätapa mahdollistaa siirräntätoimintojen kirjoittamisen
Haskell-ohjelmissa tavalla, joka on intuitiivinen ja tuttu useille ohjelmoijille, mutta samalla
Haskellin ja funktionaalisen ohjelmoinnin toivotuista ominaisuuksista pidetään kiinni:
Tyyppipäättely ja -turvallisuus auttavat ohjelmointivirheiden havaitsemista. Funktionaalisuuteen
kuuluva funktioiden ja toimintojen yhdistäminen toimii. Laiskuus ja puhtaus säilyvät.


%% IFP: Implementing monadic I/O
%% Jones: Tackling the Awkward Squad

% Ks. listaus 8 ja siellä GHC:n määritelmä Monad'sta. Ei varmaan sovi sinne, mutta ehkä ok täällä

Konsepti virtuaalisesta Maailma'sta

%% % % % % % % % % % % % %%
%
% Esitellään monadit ///
% Voisi yrittää aloittaa siitä, että sanoo jotain kategoriateoriasta ///
%  Tai siitä, miksi on olemassa kategoriateoria ja monadit ///
% Monadit luovat semantiikkaa eli kontekstia eli ympäristöä ///
%  Pitää ehkä kertoa, mitä konteksti tai ympäristö tarkoittaa tässä ///
% Monadilait
%
% Monadit ovat semanttinen asia. Haskell ottaa kategoriateorian monadit ja luovat Monadin. Toisin
% sanoen Haskell mahdollistaa ohjelmoijan määritellä oman laskennallisen ympäristönsä. Eli:
% "[Moggi(1989)] offers the interpretation of a programming language into one monad, but Haskell
% reifies monads with Monad. Reification is taking a concept used to describe the semantics of a
% language and inserting it into the language itself. Monad lets Haskell programmers define their
% own computational universes."

% I/O-operaatioiden kompositio
%  Siihen tarvitaan monadeja
%  Viitteellinen läpinäkyvyys säilyy
%  doneIO & seqIO :: monoid  ||  bindIO & unitIO :: monad

% 4.3 No way out [https://wiki.haskell.org/All_About_Monads]
% The wonderful feature of a one-way monad is that it can support side-effects in its monadic
% operations but prevent them from destroying the functional properties of the non-monadic portions
% of the program.

% FFI ja C-proseduurien kutsuminen
%  Lopulta (matalalla tasolla) siirräntä toteutetaan kutsumalla C-proseduureja (käyttöjärjestelmä ja
%  standardikirjastot)
%  Haskellissa 'ccall'
%  Koko IO-järjestelmä on toteutettu Haskellilla ccall:n päälle

% Hopkins 2012 (ei julkaisutietoja) ja Moggi 1989:
%
% Jos oletetaan ohjelma P, kategoria C, käytetyn kielen (perustyyppien) tyyppimääritelmät
% kategorian C olioille ja perusoperaatiot kyseisille tyypeille (sopiville morfismeille), on
% olemassa morfismi, joka vastaa P:tä.
% Kategorian sisäinen rakenne eli se, mitä morfismeja minkä olioiden välillä on olemassa, vastaa
% sitä kokoelmaa ohjelmia, jotka ovat kielessä (mitä ohjelmia on ja millaisten tyyppien välillä).
%
% C == category
% A == object in C
% T =~ functor from C -> C
% η == natural transformation from Id on C
% Kleisi triple (T, η, *) as the world where computation can take place
%
% Haskell:
% return     == η  (injects values into computations)
% bind (>>=) == *

% Keskimmäiset luvut keskittyvät kukin "opettamaan" lukijalle yhden osakysymyksen tai näkökulman
% käsiteltävään asiaan. Lukujen työnjaon tulisi olla selkeä ja niillä tulee olla selkeä oma
% rakenteensa, jonka valintaperuste on lukijalle kerrottu.

% Functor, Applicative, Monad:
% https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#Functor #Applicative #Monad
%
% newtype IO a = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
% newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
% RealWorld token enforces ordering through data dependence.

% Haskellissa IO monadi ///
%  Haskellin 'main' on tyypiltaan 'IO ()' ///
% RealWorld on virtuaalinen asia, jota käytetään data-riippuvuuden luontiin ///
% Kuinka "IO inside" ja IFP-paperi eroaa toisistaan? ///
% Kuinka RealWorld luodaan ja kadotetaan? ///
% Kuinka puhtaus säilytetään? ///
%  Erotellaan being ja doing (oleminen ja tekeminen?) ///
%  "In our system, the value of the entire program is a single (perhaps large) action, called mainIO,
%  and the program is executed by performing this action." ///
% Syntaksi eli 'do' ja '<-'

% \section{Luku n} Viimeistä edellinen luku on varsinaisen kontribuution koti: vertailu,
% soveltaminen, osien synteesi ja mahdolliset evaluointimenetelmät ja -tulokset pääroolissa.


\section{Yhteenveto}

% Yleensä hieman johdantoa lyhyempi.
% Muistuttaa mieleen tutkimuskysymyksen, mainitsee tärkeimmät tulokset ja niiden perusteet.
%  Keskittyy impaktiin ja esimerkiksi suosituksiin. Ei vain summeeraa luku kerrallaan aikaisempaa
%  tekstiä.

% Monad
% http://lambda-the-ultimate.org/node/3051
% https://jeltsch.wordpress.com/2013/02/09/some-interesting-features-of-haskells-type-system
% * kinds == types of types
% * type classes: kind *
% * constructor classes: kind * -> *
% * multiparameter type classes: e.g. conversion val -> val'

\bibliographystyle{babalpha-lf}
\bibliography{viitteet}

\end{document}

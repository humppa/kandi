\documentclass[finnish]{tktltiki2}
% vim: set textwidth=100 :
% rubber: module pdftex

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

\usepackage{listings}
\renewcommand{\lstlistingname}{Listaus}
\lstset{captionpos=b,frame=single,language=Haskell}

\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

\usepackage[nottoc]{tocbibind}
\settocbibname{Lähteet}

\title{Haskell ja monadinen imperatiivisuus}
\author{Tuomas Starck}
\date{\today}
\level{Referaatti}
\abstract{Referaatti.}

\keywords{haskell}

% \classification{}

\begin{document}

\frontmatter

\maketitle
\makeabstract

\tableofcontents

\mainmatter

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\fixme}[1]{\emph{#1}}


\section{Johdanto}

% Jäsennelty asianmukaisesti (kenelle, miksi, millaisessa ympäristössä; ratkaisun lähestymistapa;
%  tutkimuskysymys, tulokset ja impakti; loppulukujen roolitus), pituus 1,5 - 2 s.
% Esim:
% 1.1 Peliteoria ja pelipuu
% 1.2 Minimax ja heuristiikka

\fixme{Allaoleva ei oikeastaan ole mikään johdanto ja ainakin osa pitää kirjoittaa uudestaan. Ota
aluksi selvää, että millainen johdannon pitäisi olla. Tämän hetken teksti puhtaudesta ja
laiskuudesta lienee relevantti jatkon kannalta, joten pidä ne tallessa tai siirrä kappaleeseen 2.}

\subsection{Haskell}

Haskell sai alkunsa vuonna 1987 Functional Programming and Computer Architecture -konferenssin
yhteydessä pidettyssä tapaamisessa, jossa päätettiin suunnitella ja kehittää uusi ohjelmointikieli.
Ennen Haskellia oli olemassa lukuisia funktionaalisia ohjelmointikieliä, mutta vaihtoehtojen
ylitarjonta sipraloi funktionaalisen ohjelmoinnin kentän ja hidasti sen edistystä. Kielen
kehittämistä varten perustettiin komitea, jonka tavoitteena oli luoda yksi yhtenäinen
funktionaalinen ohjelmointikieli. Komitean yksi ensimmäisistä saavutuksista oli uuden kielen
nimeäminen Haskelliksi.~\cite{hoh07}

\subsection{Laiskuus}

Haskell-komitean merkittävin yhteinen tavoite oli tehdä Haskellista laiska. Laiskuudella
tarkoitetaan sitä, että ohjelman lausekkeet evaluoidaan vasta silloin, kun niiden palauttama arvo on
tarpeen. Laiska suoritus mahdollistaa muun muassa äärettömien tietorakenteiden määrittelyn ja
käsittelyn, sillä Haskellin suoritusympäristö ei pyri evaluoimaan niitä loppuun saakka, joten
ohjelma ei jää jumiin.

Yleisesti ottaen Haskell-komitean pyrkimys oli käyttää olemassaolevia ja hyvin tunnettuja
tekniikoita suunnittelutyönsä pohjana. Laiskuudesta oli noin vuosikymmenen verran kokemusta
Haskellin synnyn aikaan, joten se ei ollut uusi keksintö.

Laiskuus ei ole täysin ongelmaton valinta. Laiskan suorituksen on pidettävä kirjaa siitä, mitkä osat
ohjelmaa ovat suorittamatta, ja se kasvattaa yleiskustannuksia. Kirjanpidosta seuraava hidastus on
kuitenkin vakioinen ja verrattain pieni. Suurempi ongelma on se, että laiskan suorituksen
tilavaativuutta on vaikea arvioida ja se saattaa kasvaa ylilineaarisesti. Haskelliin on siksi
lisätty sekä tietorakenteita, jotka eivät ole laiskoja, että keino pakottaa lausekkeen evaluaatio,
jolloin laiskuuden voi poistaa sellaisesta kohdasta ohjelmaa, jossa se on haitaksi.

\subsection{Puhtaus}

Laiskuuden välitön seuraus on se, että evaluointijärjestys määräytyy tarpeen mukaan, jolloin
vastaavasti sivuvaikutusten käsittelyä on vaikeaa toteuttaa mielekkäästi. Sivuvaikutuksilla
tarkoitetaan esimerkiksi siirrännän käsittelyä (engl. \emph{input/output}) tai yleisesti ottaen mitä
tahansa ulkoista tilanmuutosta~\fixme{parempiselitys!}.

Haskell-komitean ratkaisu oli tehdä Haskellista puhdas kieli, jolloin funktioilla ei ole lainkaan
sivuvaikutuksia. Tässä mielessä Haskellin funktiot ovat paitsi nimeltään niin myös merkitykseltään
vastaavanlaisia matemaattisten funktioiden kanssa -- molemmat palauttavat samalla syötteellä aina
saman arvon.

Puhtauden vaikutukset ovat kaikenkattavat. Koska sivuvaikutuksia ei sallittu, oli Haskellin
alkuaikoina siirräntä tuskallisen hankalaa. Pakon edessä kehitettiin monadinen siirräntä, jota
voidaan pitää yhtenä Haskellin merkittävimmistä panostuksista ohjelmointikielten kehitykselle.
Keskustelu siitä, onko puhtaan kielen ja monadisten sivuvaikutusten yhdistelmä paras lähestymistapa
ohjelmistojen kehitykselle, on yhä kesken, mutta Haskellin tarjoama ehdotus on ainakin mullistava ja
elegantti. Lisäksi se on synnyttänyt paljon tutkimusta monadeista ja tilan kapseloinnista.

\subsection{Tyyppiluokat}

Tyyppiluokkia pidetään nykyisin yhtenä Haskellin tunnusmerkillisimmistä ominaisuuksista. Alunperin
tyyppiluokat tuotiin osaksi kieltä, koska oli tarve ratkaista yhtäsuuruuden vertaamisen ja
numeeristen operaatioiden ylikuormitus. Haskell-komitean tavoite oli suunnitella kieli käyttäen
olemassaolevia ja perusteellisesti tunnettuja menetelmiä, mutta Haskellia edeltäneissä
funktionaalisissa kielissä, kuten Mirandassa tai Standard ML:ssä, ei ylikuormitusta oltu ratkaistu
yhtenäisellä tavalla. Lisäksi aiemmin käytetyissä menetelmissä oli heikkouksia, kuten esimerkiksi
Mirandan polymorfinen yhtäsuuruusvertailu~\fixme{laajenna?}, joka saattoi johtaa ajonaikaisiin
virhetilanteisiin.

Tyyppiluokat mahdollistavat nimensä mukaisesti tyyppien luokittelun sen perusteella, mitä
ylikuormitettuja operaatioita ne tukevat. Esimerkiksi Haskellissa luokkaan \code{Eq} kuuluvalle
tyypille on toteutettu yhtäsuuruusvertailu. Tällöin käännösvaiheessa on mahdollista tarkistaa, että
\code{==}-operaattoria käytetään vain sellaisten tyyppien kesken, jotka kuuluvat
\code{Eq}-luokkaan. Vaikka tyyppiluokat olivat uusi keksintö eikä niiden toimivuutta oltu
todistettu aiemmin, Haskell-komitea päätyi omaksumaan ne osaksi kieltä, sillä niiden avulla kaikkien
tyyppien ylikuormitus oli ratkaistavissa yhtenäisellä, järjestelmällisellä ja modulaarisella
tavalla.

\fixme{FIXME} Jälkikäteen ajateltuna tyyppiluokkien ottaminen osaksi Haskellia oli onnekas valinta,
jolla on ollut kauaskantoisia vaikutuksia, sillä tyyppiluokat ovat monikäyttöinen työkalu ja niiden
avulla voi tehdä paljon muutakin kuin toteuttaa ylikuormituksen. Yksi merkittävä edistysaskel
Haskellin ja tyyppiluokkien kehitykselle oli ehdotus tyyppimuodostajan parametroimisesta
tyyppimuuttujan sijaan. Tämä mahdollisti korkeamman asteen polymorfismin (engl. \emph{higher-kinded
polymorphism}), jonka välitön sovellus oli monadien toteuttaminen.

Koodiesimerkkejä käytetään ongelmien ja ratkaisujen havainnollistamiseen. Esimerkit seuraavat
syntaksiltaan Haskellia silloinkin, kun ne ovat pseudokoodia, joka ei käänny Haskell-ohjelmaksi.
Listauksessa~\ref{lst:esittely} esitellään käytetty syntaksi, jossa on kaksi osaa: funktion tyypin
määrittely ja varsinainen funktion määrittely. Tyyppimäärittely alkaa funktion nimellä, jonka
jälkeen tulee kaksi kaksoispistettä, jota seuraa mahdolliset parametrit ja paluuarvo eroteltuna
nuolella (\code{->}). Funktion määrittely alkaa myös funktion nimellä, jota seuraa mahdolliset
parametrit (tässä esimerkissä \code{x} ja \code{y}), joiden jälkeen tulee yhtäsuuruusmerkki ja
funktion vartalo.

\begin{lstlisting}[label={lst:esittely},caption={Syntaksin esittely}]
summa :: Int -> Int -> Int
summa x y = x + y
\end{lstlisting}

\section{Siirrännän vaikeus laiskassa ja puhtaassa kielessä}

% Ollaanko me määritelty siirräntä missään vaiheessa? Tulostus, syötteen lukeminen, FFI,
% tilamanipulaatiot...

% Purkaa auki teknisemmälle yleisölle samalla käsitteitä määritellen tutkimuskysymyksen, ratkaisuille
%  ympäristöstä esiintulevat vaatimukset ja keskeiset käsitteet näiden asioiden esittelemiseksi.
% Antaa riittävästi termistöä ja kysymyksenasetteluja, jotta myöhempänä teksissä on mahdollisuus
%  analyysiin ja evaluointiin.

Haskellin kehityksen alkutaipaleella pohdittiin siirrännän toteuttamista ja siihen liittyviä
ongelmia. Valmista hyvänä pidettyä ratkaisua ei ollut olemassa, sillä olemassaolevien puhtaiden
funktionaalisten kielten siirräntää pidettiin epätyydyttävänä tai kielessä oli sallittu
sivuvaikutukset. \fixme{Lisää?}

\subsection{Puhtaus}

Puhtaasta laskennasta on monia hyötyjä. \fixme{Esimerkiksi rinnakkaista ohjelmointia pidetään
perinteisesti vaikeana, ja yksi merkittävä syy ohjelmointivirheille on se, että suorituksen eri
haarat lukevat tai muuttavat jaettua tilaa virheellisesti.} Puhdas rinnakkainen laskenta sen sijaan
on sivuvaikutuksetonta, joten se on immuuni samoille ongelmille.

% https://en.wikipedia.org/wiki/Dijkstra_Prize

Sivuvaikutusten puute tarkoittaa myös sitä, että Haskell on viitteellisesti läpinäkyvä (engl.
\emph{referentially transparent}). Toisin sanoen minkä tahansa Haskellin lausekkeen voi korvata
kyseisen lausekkeen arvolla ilman, että ohjelman merkitys muuttuu. Käytännössä viitteellinen
läpinäkyvyys mahdollistaa optimoinnin, jossa kääntäjä pelkistää kaikki toistuvat viitteet yhdeksi.
Esimerkiksi listauksessa~\ref{lst:kuutio} muuttujan \code{x} arvo pitää selvitää vain kerran, jonka
jälkeen saadulla \code{x}:n arvolla korvataan jokainen \code{x}:n ilmentymä ja kertolaskut voidaan
laskea.

\begin{lstlisting}[label={lst:kuutio},caption={Puhdasta laskentaa}]
kuutio x = x * x * x
\end{lstlisting}

Esimerkin yksinkertaisuus saattaa hämätä, joten on syytä muistaa, että \code{x} voi olla
laskennallisesti mielivaltaisen haastava funktio, joten optimointi voi olla merkittävä. Lisäksi
ilman puhtautta \code{x}:n arvo saattaisi olla riippuvainen esimerkiksi ulkoisesta syötteestä,
jolloin optimointia ei voisi tehdä yhtä huolettomasti. Toisaalta aina puhtaudesta johtuva
optimointi ei johda toivottuun lopputulokseen.

\begin{lstlisting}[label={lst:samat},caption={Kaksi samaa funktiota}]
lueKaksiRivia = { readLine; readLine }
\end{lstlisting}

Esimerkissä~\ref{lst:samat} käytetään kahdesti samaa funktiota, jonka tarkoitus on lukea käyttäjän
antama syöte. Koska kääntäjä luottaa puhtauteen ja optimoi identtiset funktiot yhdeksi
evaluaatioksi, tapahtuu varsinainen luku vain kerran, sillä sen jälkeen molempien funktioiden
ilmentymä voidaan korvata kerran tehdyn evaluaation palauttamalla arvolla. Siirrännän käsittelyssä
puhtaus ja sen seuraukset eivät aina ole toivottavia.

\subsection{Laiskuus}

Laiska suoritus sopii hyvin yhteen puhtaan funktionaalisen kielen kanssa, mutta sekin tekee
siirrännän käsittelyn vaikeaksi. Listauksessa~\ref{lst:tulostus} on esimerkkiohjelma, jossa
määritellään funktio \code{sanoHaskell}, jonka tarkoitus on tulostaa merkkijono `Haskell'
oletustulostusvirtaan.

\begin{lstlisting}[label={lst:tulostus},caption={Tulostava esimerkkiohjelma}]
sanoHaskell = print 'Haskell'
\end{lstlisting}

Imperatiiviseen paradigmaan tottunut saattaisi olettaa, että ohjelma tulostaa `Haskell' ja lopettaa.
Laiska suoritus kuitenkin johtaa siihen, ettei mitään tulostu. Funktiota \code{print} ei koskaan
evaluoida, sillä sivuvaikutuksista ei välitetä eikä funktio palauta mitään sellaista arvoa, joka on
tarpeen ohjelman suorittamiseksi. Toisin sanoen ohjelman tulostus optimoidaan pois, vaikka se on
ohjelman ainoa varsinainen tarkoitus.

Laiskuuteen ja siirräntään liittyy myös toinen ongelma, joka on hieman hienovaraisempi.
Listauksen~\ref{lst:jarjestys} esimerkissä määritellään funktio \code{sanoHeiMaailma}, jonka on
tarkoitus suorittaa kaksi merkkijonon tulostusta. Imperatiivisissa ohjelmissa suoritus on
tavanomaisesti ahnetta ja ohjelman suoritus seuraa kirjoitetun koodin rakennetta, mutta sama sääntö
ei päde laiskaan evaluointiin. Tästä seuraa se, ettei ole olemassa takeita siitä, missä
järjestyksessä esimerkkiohjelman tulostukset suoritetaan.

\begin{lstlisting}[label={lst:jarjestys},caption={Kahden tulostuksen pseudokoodi}]
sanoHeiMaailma = { print 'Hei'; print 'maailma' }
\end{lstlisting}

Toisin sanoen siinäkin tapauksessa, että tulostukset suoritettaisiin laiskuudesta huolimatta,
saattaa merkkijono `maailma' tulostua ennen merkkijonoa `Hei'. Tämä on luonnollisesti merkittävä
ongelma, sillä yleisessä käyttötapauksessa siirrännän käsittelyn tulee tapahtua määrätyssä
järjestyksessä, jotta ohjelma toimii tarkoituksenmukaisesti.

\subsection{Kohti imperatiivisuutta}

Listauksessa~\ref{lst:ratkaisu} on ohjelma, jonka käyttötarkoitus on sama kuin aiemmassa
listauksessa~\ref{lst:samat} eli ohjelman tulisi lukea syöte kahdesti, mutta toteutusta on
laajennettu siten, että puhtauden ja laiskuuden aiheuttamat ongelmat on pyritty ratkaisemaan.
Lisäksi tällä kertaa käytettyjen funktioiden tyyppimäärittelyt ovat kirjoitettu näkyviin.
Ratkaisussa on käytetty tekaistuja parametreja, joiden avulla suoritusjärjestys pakotetaan
halutunlaiseksi. Tekaistujen parametrien tyyppi ei ole tärkeä, ja listauksessa käytetty \code{Int}
on valittu vain yhtenä esimerkkinä kaikista mahdollisuuksista.

\begin{lstlisting}[label={lst:ratkaisu},caption={Suoritusjärjestys riippuvuuksien avulla}]
lueRivi       :: Int -> ( String,  Int)
lueKaksiRivia :: Int -> ([String], Int)

lueKaksiRivia p0 = ([s1, s2], p2) where
  (s1, p1) = lueRivi p0
  (s2, p2) = lueRivi p1
\end{lstlisting}

Funktio \code{lueKaksiRivia} palauttaa arvot \code{s1} ja \code{s2}, jotka edustavat niitä
merkkijonosyötteitä, joiden lukeminen on ohjelman varsinainen tavoite. Lisäksi ohjelma palauttaa
tekaistun arvon \code{p2}. Ohjelman toiminta on helpoin päätellä seuraamalla ohjelman suoritusta
kääteisessä järjestyksessä. Jotta \code{p2}:n arvo saadaan selville, on välttämätöntä suorittaa
funktio \code{lueRivi p1}. Jotta se voidaan suorittaa, täytyy saada selville arvo \code{p1}, joka
vuorostaan vaatii funktion \code{lueRivi p0} suorituksen ensin. Tällöin tekaistuilla parametreilla
on saavutettu se, että funktioilla \code{lueRivi} on muuttujien arvoon liittyvä riippuvuus, jolloin
laiska suoritus ei voi poimia suoritusjärjestystä mielivaltaisesti.

Samalla vältetään puhtaudesta juontuvat ongelmat. Funktioita \code{lueRivi p0} ja \code{lueRivi p1}
ei voi pelkistää yhdeksi evaluaatioksi, sillä ne saavat eri parametrit.

Funktion \code{lueKaksiRivia} saama parametri \code{p0} ei ole välttämätön tämän esimerkin kannalta,
mutta on tärkeä laajemmassa kontekstissa, sillä se mahdollistaa funktioiden koostamisen (engl.
\emph{function composition}). Jos funktiolle \code{lueRivi} ei voisi antaa mitään parametria, ei
puhtauden ja laiskuuden ongelmia olisi voitu ratkaista tekaistuilla parametreilla. Vastaavasti ilman
parametria \code{p0} olisi funktiolla \code{lueKaksiRivia} sama ongelma laajemman ohjelman
kontekstissa. Tästä syystä ei ole lainkaan sattumaa, että käytettyjen funktioiden tyyppimääritelmät
ovat hyvin samankaltaiset, sillä molempien funktioiden on tarkoitus toteuttaa siirräntää puhtaassa
ja laiskassa kielessä.

Vaikka tämän esimerkin ohjelman voi nähdä toimivan tarkoituksenmukaisella tavalla, on se samalla
muuttunut huomattavasti monimutkaisemmaksi. Ohjelma on vaikeaselkoinen, koska eri parametrien
tarkoitus ei ole ilmeinen, ja toisaalta tekaistujen parametrien käyttö ohjelman suorituksen
ohjaamiseen on semanttisesti ongelmallista.

% Tähän voisi lisätä monadisen I/O:n hyvät puolet:
%  composable
%  easily extensible
%  effiient
%  ^ archieved by transformations
%  extendable to interleaved I/O
%  extendable to in-place manipulation
%  only Hindley-Milner required

\section{Nimetön kappale} %%IFP: Overview

\subsection{Toiminto ja suoritus}

% action  -- toimintoa
% perform -- suorittaa

% Haskell-ohjelma on yksi iso \emph{toiminto} nimeltään mainIO, jonka \emph{suoritus} vastaa
% ohjelman suorittamista.

Ratkaisuksia siirrännän ongelmiin Haskellissa erotellaan toisistaan olemassaoleminen ja tekeminen.
\fixme{Muotoile edellinen virke paremmin.} Funktionaalisen kielen lauseke ilmaisee arvoa, kun taas
siirräntä on luonteeltaan suorite, joka pitäisi toteuttaa. Haskelliin on siksi lisätty
\code{IO}-tyyppi, joka ilmaisee toimintoa (engl. \emph{action}), jonka suoritus (engl.
\emph{perform}) voi tehdä siirräntää ja palauttaa arvon. Jatkossa toiminnolla tarkoitetaan aina
funktiota, joka on \code{IO}-tyyppiä.

\code{IO} on yhdistelmätyyppi (engl. \emph{algebraic data type}), joka ottaa parametrikseen
palautteen tyypin. Esimerkiksi funktio tyyppiä \code{IO Int} palauttaa kokonaislukuarvon
suoritettuaan siirrännän. \code{IO}-tyypin määrittelyyn riittää klassinen
Hindley--Milner-tyyppijärjestelmä, joten sen käyttöönotto ei vaatinut muita muutoksia Haskelliin.
\fixme{HM:ää ei ole mainittu aiemmin. Se pitäisi ehkä laittaa edelliseen kappaleeseen.}

Erottelemalla toiminnon suorittamisesta \code{IO}-tyyppiset funktiot kapseloivat siirrännän siten,
että ne ovat yhteensopivat Haskellin puhtaan funktionaalisen paradigman kanssa säilyttäen
viitteellisen läpinäkyvyyden. Toisin sanoen toiminnot ovat tavallisia funktiota, joita voidaan
välittää argumenttina, koostaa osaksi korkeamman asteen funktioita (engl. \emph{function
composition}) ja yleisesti ottaen käsitella kaikilla funktionaalisen kielen keinoilla.

Toiminnon ja suorituksen erottelu johtaa luonnollisesti kysymykseen siitä, mikä saa aikaan
toimintojen suorittamisen? Haskellin ratkaisu on määritellä ohjelma toiminnoksi nimeltään
\code{main}, jonka suoritus vastaa koko ohjelman suorittamista. Koska Haskell-ohjelma on
funktionaalisesta semantiikasta johtuen mielivaltainen yhdistelmä matalamman tason funktioita ja
toimintoja, johtaa \code{main}-toiminnon suoritus myös matalan tason toimintojen suorittamiseen
silloin, kun \code{main}-toiminnon suoritus sitä vaatii.

\subsection{Toimintojen yhdistäminen}

Listauksessa~\ref{lst:bind} on ohjelma, joka lukee yhden merkin vakiosyötteestä ja tulostaa sen
vakiotulosteeseen. Jos listauksen tyyppimääritelmät jättää huomioimatta, on tämänkertainen esimerkki
validia Haskellia, jonka voi kääntää toimivaksi ohjelmaksi. Ohjelma käyttää \code{getChar} ja
\code{putChar} toimintoja, joista ensimmäinen on tyypiltään \code{IO Char}, sillä sen suorituksen
jälkeinen paluuarvo on merkki, ja jäljempi on tyypiltään \code{Char -> IO ()}, sillä se ottaa
argumentikseen tulostettavan merkin eikä ei palauta mitään arvoa. Haskellissa tyhjiä sulkeita
käytetään olemattoman arvon merkitsemiseen, ja niiden käyttö on välttämätöntä tässä tapauksessa,
sillä \code{IO} vaatii tyyppiparametrin.

\begin{lstlisting}[label={lst:bind},caption={Kompositio ja sidosfunktion käyttö}]
getChar :: IO Char
putChar :: Char -> IO ()
(>>=)   :: IO a -> (a -> IO b) -> IO b

main :: IO ()
main = getChar >>= putChar
\end{lstlisting}

% bind ei ole language construct vaan ihan vaan funktio

Esimerkin toiminnot ovat yhdistetty \verb|(>>=)| funktiolla, joka luetaan \emph{bind} eli suomeksi
sidos. Bindia käytetään tavallisesti sisämerkintänä (engl. \emph{infix notation}), joten esimerkissä
bind saa argumenteikseen toiminnot \code{getChar} ja \code{putChar}. Bindin toteutus ei ole
esimerkissä näkyvillä, mutta tyyppimääritelmä riittää oleellisen toiminnan päättelyyn.
\fixme{Mainitse, että bind on polymorfinen!} Ensimmäinen parametri on muotoa \code{IO a}, jossa
tyyppimuuttuja \code{a} on tämän esimerkin tapauksessa \code{Char}, sillä \code{getChar} palauttaa
merkin. Bindin toinen parametri on funktio \code{putChar}, joka saa aiemmin luetun merkin
syötteekseen ja palauttaa tyhjän arvon, joten tyyppiparametri \code{b} on \code{()}. Lopuksi bind
palauttaa arvon \code{IO ()}, joka vastaa \code{main}-toiminnon arvoa, joten ohjelma läpäisee
tyyppitarkastuksen.

Bind ratkaisee laiskan evaluoinnin ongelman luomalla tietoriippuvuuden (engl. \emph{data
dependency}). Koska ensimmäisen toiminnon paluuarvoa tarvitaan toisen toiminnon suorittamiseen,
täytyy ensimmäinen toiminto suorittaa ensin.

\fixme{Viitteellinen läpinäkyvyys säilyy. Puhtaus on ratkaistu. Jne...}

\subsection{Imperatiivisuus uudelleen fixme}

\section{Täällä vihdoin jotain monadeista?}

%% % % % % % % % % % % % %%

% I/O-operaatioiden kompositio
%  Siihen tarvitaan monadeja
%  Viitteellinen läpinäkyvyys säilyy
%  doneIO & seqIO :: monoid  ||  bindIO & unitIO :: monad

% Imperatiivinen ohjelmointi
%  Monadisuus mahdollistaa imperatiivisen tyylin
%  Muttei funktionaalisia hyötyjä ei menetetä (korkean asteen funktiot, kompositio, laiskuus...)

% FFI ja C-proseduurien kutsuminen
%  Lopulta (matalalla tasolla) siirräntä toteutetaan kutsumalla C-proseduureja (käyttöjärjestelmä ja
%  standardikirjastot)
%  Haskellissa 'ccall'
%  Koko IO-järjestelmä on toteutettu Haskellilla ccall:n päälle

% IFP
% 2 Overview
% We need a way to reconcile being with doing: an expression in a functional language denotes a value,
% while an I/O command should perform an action. We integrate these worlds by providing a type IO a
% denoting actions that, when performed, may do some I/O and then return a value of type a.

% \section{Monadit}

% Hopkins 2012 (ei julkaisutietoja) ja Moggi 1989:
%
% Jos oletetaan ohjelma P, kategoria C, käytetyn kielen (perustyyppien) tyyppimääritelmät
% kategorian C olioille ja perusoperaatiot kyseisille tyypeille (sopiville morfismeille), on
% olemassa morfismi, joka vastaa P:tä.
% Kategorian sisäinen rakenne eli se, mitä morfismeja minkä olioiden välillä on olemassa, vastaa
% sitä kokoelmaa ohjelmia, jotka ovat kielessä (mitä ohjelmia on ja millaisten tyyppien välillä).
%
% C == category
% A == object in C
% T =~ functor from C -> C
% η == natural transformation from Id on C
% Kleisi triple (T, η, *) as the world where computation can take place
%
% Haskell:
% return     == η  (injects values into computations)
% bind (>>=) == *
%
% Why!?
% "Moggi seeks to capture the intuitive notion of a computation in the most general setting
% possible." -- Kategoriateoreettinen lähestymistapa tarjoaa yhdenmukaisuudelle ja pysähtymiselle
% luonnollisen selityksen. -- "That existence and equivalence are so readily definable suggests that
% far from just being a way to hide I/O or statefulness, Monads and their attendant laws express the
% conditions satisfied by a computation strategy."
%
% Monadit ovat semanttinen asia. Haskell ottaa kategoriateorian monadit ja luovat Monadin. Toisin
% sanoen Haskell mahdollistaa ohjelmoijan määritellä oman laskennallisen ympäristönsä. Eli:
% " [Moggi(1989)] offers the interpretation of a programming language into one monad, but Haskell
% reifies monads with Monad. Reification is taking a concept used to describe the semantics of a
% language and inserting it into the language itself. Monad lets Hakell programmers define their own
% computational universes."

% Esitellään monadit ///
% Voisi yrittää aloittaa siitä, että sanoo jotain kategoriateoriasta ///
%  Tai siitä, miksi on olemassa kategoriateoria ja monadit ///
% Monadit luovat semantiikkaa eli kontekstia eli ympäristöä ///
%  Pitää ehkä kertoa, mitä konteksti tai ympäristö tarkoittaa tässä ///
% Monadilait

% Keskimmäiset luvut keskittyvät kukin "opettamaan" lukijalle yhden osakysymyksen tai näkökulman
% käsiteltävään asiaan. Lukujen työnjaon tulisi olla selkeä ja niillä tulee olla selkeä oma
% rakenteensa, jonka valintaperuste on lukijalle kerrottu.

% Functor, Applicative, Monad:
% https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#Functor #Applicative #Monad
%
% newtype IO a = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
% newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
% RealWorld token enforces ordering through data dependence.

% Haskellissa IO monadi ///
%  Haskellin 'main' on tyypiltaan 'IO ()' ///
% RealWorld on virtuaalinen asia, jota käytetään data-riippuvuuden luontiin ///
% Kuinka "IO inside" ja IFP-paperi eroaa toisistaan? ///
% Kuinka RealWorld luodaan ja kadotetaan? ///
% Kuinka puhtaus säilytetään? ///
%  Erotellaan being ja doing (oleminen ja tekeminen?) ///
%  "In our system, the value of the entire program is a single (perhaps large) action, called mainIO,
%  and the program is executed by performing this action." ///
% Syntaksi eli 'do' ja '<-'

% Tästä on voitu tiputtaa feikatut parametrit, koska monadi
% \begin{lstlisting}[label={lst:monadinenio},caption={Fixme}]
% luerivi       :: IO String
% lueKaksiRivia :: IO (String, String)
%
% lueKaksiRivia = do
%   rivi1 <- luerivi
%   rivi2 <- luerivi
%   return (rivi1, rivi2)
% \end{lstlisting}

% Testaa toimiiko tää ylipäätään!
% \begin{lstlisting}[label={lst:monadinenio},caption={Fixme}]
% lueKaksiRivia = (luerivi, luerivi)
% \end{lstlisting}

% \fixme{Tässä kappaleessa kerrotaan siitä, kuinka monadit passaavat maailmaa ja toteuttavat kivasti
% ja elegantisti sen, mikä edellisessä kappaleessa tehtiin käsin. Ja do-notaatiosta voi kertoa.}

% \section{Luku n}

% Viimeistä edellinen luku on varsinaisen kontribuution koti: vertailu, soveltaminen, osien
% synteesi ja mahdolliset evaluointimenetelmät ja -tulokset pääroolissa.

\section{Yhteenveto}

% Yleensä hieman johdantoa lyhyempi.
% Muistuttaa mieleen tutkimuskysymyksen, mainitsee tärkeimmät tulokset ja niiden perusteet.
%  Keskittyy impaktiin ja esimerkiksi suosituksiin. Ei vain summeeraa luku kerrallaan aikaisempaa
%  tekstiä.

%% % % % % % % % % % % % %%

% Monad
% http://lambda-the-ultimate.org/node/3051
% https://jeltsch.wordpress.com/2013/02/09/some-interesting-features-of-haskells-type-system
% * kinds == types of types
% * type classes: kind *
% * constructor classes: kind * -> *
% * multiparameter type classes: e.g. conversion val -> val'

Kappale, jossa käytetään~\cite{hoh07} kaikki~\cite{tcih96} viitteet, että ne~\cite{ifp93}
tulevat~\cite{moggi89} listattua~\cite{cm90} loppuun.

\bibliographystyle{babalpha-lf}
\bibliography{viitteet}

\end{document}
